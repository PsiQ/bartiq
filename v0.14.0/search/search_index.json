{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bartiq","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Bartiq is a Python library for compiling and analyzing fault-tolerant quantum algorithms to understand their computational requirements. It focuses on Quantum Resource Estimation (QRE), tracking key logical-level resources including T-gates, Toffolis, circuit active volume, and qubit count. In <code>bartiq</code>, quantum algorithms are expressed as subroutines with locally defined symbolic resource costs, which are used by its compilation engine to generate global resource costs from these local definitions.</p> <p>To install <code>bartiq</code> via <code>pip</code>, run <pre><code>pip install bartiq\n</code></pre>  More detailed instructions can be found on the installation page.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>As an example we consider the following circuit, from Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity\u00a0\u29c9. This circuit prepares an arbitrary state with $L$ unique amplitudes, and is equivalent to classical alias sampling. From Fig. 11 in the paper:</p> <p></p> <p>In order to quickly get started with <code>bartiq</code>, you can load this as an example routine and use it as follows (click here to download <code>alias_sampling_basic.json</code>):</p> <p><pre><code>import json\nfrom bartiq import compile_routine, evaluate\nfrom qref import SchemaV1\n\nwith open(\"alias_sampling_basic.json\", \"r\") as f:\n    routine_dict = json.load(f)\n\nuncompiled_routine = SchemaV1(**routine_dict)\ncompiled_routine = compile_routine(uncompiled_routine).routine\n</code></pre> After loading the alias sampling JSON file we cast it to the <code>qref.SchemaV1</code>\u00a0\u29c9 type, our data format\u00a0\u29c9 for representing quantum algorithms for the purposes for resource estimation. This provides us with an <code>uncompiled_routine</code>, which we can then compile with <code>compile_routine</code>. The compilation engine will propagate the resource costs from low-level subroutines up, to create aggregated global costs for the whole circuit. </p> <p>To see, for example, the symbolic $T$-gate count for this circuit: <pre><code>print(compiled_routine.resources[\"T_gates\"].value)\n&gt;&gt;&gt; 4*L + 8*L/multiplicity(2, L) + 4*mu + O(log2(L)) - 8\n</code></pre></p> <p>To obtain numeric resource costs we can assign values to our variables $L$ and $\\mu$ and then <code>evaluate</code> the routine</p> <pre><code>assignments = {\"L\": 100, \"mu\": 10}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\n\nprint(evaluated_routine.resources[\"T_gates\"].value)\n&gt;&gt;&gt; O(log2(100)) + 832\n</code></pre> <p>As <code>bartiq</code> is primarily symbolic in nature, we do not have to assign values for all of our variables: <pre><code>assignments = { \"mu\": 10}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\n\nprint(evaluated_routine.resources[\"T_gates\"].value)\n&gt;&gt;&gt; 4*L + 8*L/multiplicity(2, L) + O(log2(L)) + 32\n</code></pre></p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>For more comprehensive examples, please see the tutorials.</li> <li>If you are interested in learning more about how the <code>bartiq</code> compilation engine works, please see the compilation page.</li> <li>For common issues, please check troubleshooting section.</li> <li>You can find reference documentation for the public API of <code>bartiq</code>'s python package, please go to reference.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#via-pip","title":"Via <code>pip</code>","text":"<p>To install <code>bartiq</code> run:</p> <pre><code>pip install bartiq\n</code></pre> <p><code>bartiq</code> also has a number of optional extras, which can be installed with the following commands:</p> <p><pre><code># To use jupyter integrations\npip install \"bartiq[jupyter]\"\n\n#\u00a0To use optimization tooling\npip install \"bartiq[optimization]\"\n\n# To use a full suite of interactive tools\npip install \"bartiq[interactive]\"\n</code></pre> Installing <code>bartiq[interactive]</code> encapsulates the <code>bartiq[jupyter]</code> install, with additional packages for interactive plotting of routines. Multiple extras can be installed with comma separation inside the square brackets, i.e. <code>bartiq[jupyter,optimization]</code>.</p> <p>Note</p> <p>To use the QREF\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For a source install run:</p> <p><pre><code># Clone bartiq repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install .\n</code></pre> With a source install optional extras can be installed via <code>pip install \".[jupyter]\"</code> and similarly for <code>optimization</code>, <code>interactive</code>.</p>"},{"location":"installation/#development","title":"Development","text":"<p>For development we recommend installing using <code>poetry</code>:</p> <pre><code>git clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install poetry\npoetry install\n</code></pre> <p>With <code>poetry</code>, install extras with <code>poetry install -E jupyter</code>, and similarly for <code>optimization</code>, <code>interactive</code>.</p> <p>This will create a virtual environment for you and install all developer and docs dependencies within it. For Poetry 2.0 and above, you can enter this environment by running: <pre><code>$(poetry env activate)\n</code></pre> or, for Poetry 1.x: <pre><code>poetry shell\n</code></pre></p> <p>We encourage the use of <code>pre-commit</code> hooks in <code>bartiq</code> development to maintain code quality standards. You can view the documentation for <code>pre-commit</code> here\u00a0\u29c9. Prior to committing anything to your branch, run the following commands: <pre><code>poetry run pre-commit install\n</code></pre> This will ensure that any committed changes conform to <code>bartiq</code> development standards. </p> <p>To run all <code>pre-commit</code> hooks locally: <pre><code>poetry run pre-commit run --all\n</code></pre> This command will print a summary of the current code quality in your branch.</p> <p>Warning</p> <p>If using Visual Studio Code, the <code>git</code> integration in Source Control does not detect <code>pre-commit</code> hooks. To use these, <code>git</code> commands must be run through the terminal in the installed <code>bartiq</code> virtual environment.</p>"},{"location":"installation/#tests","title":"Tests","text":"<p>To run the test suite, from the project root directory run:</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"installation/#documentation","title":"Documentation","text":"<p>To build docs, from the project root directory run:</p> <pre><code>poetry run mkdocs serve\n</code></pre>"},{"location":"limitations/","title":"Known limitations","text":"<p>This page lists some prominent limitations and missing features. Please keep in mind that <code>bartiq</code> is currently under active development, so some of these might soon be resolved. For an up-to-date list of all planned features, please see the GitHub issues page\u00a0\u29c9.</p>"},{"location":"limitations/#balance-between-exact-and-approximate-costs","title":"Balance between exact and approximate costs","text":"<p>For some quantum algorithms, the expression for their cost might depend on the inputs. For example the uncontrolled SWAP gate can be implemented with just 3 CNOTs (no T gates), but the controlled version requires using T gates, depending on the number of controls. This effectively introduces a conditional cost. It can be modelled using bartiq in a couple of ways: - using a step function (Heaviside theta) allows us to model cases where the cost has different values depending if a given parameter is below or above certain threshold. - using piecewise sympy function\u00a0\u29c9 - using user-defined functions instead of sympy expressions</p> <p>However, all these methods introduce additional complexities which may or may not be appropriate for a given use-case. Ultimately, bartiq does not provide any native approach for dynamic definition of routines based on the topology, so users are responsible for such decision-making prior to compilation.</p>"},{"location":"limitations/#keeping-track-of-where-given-register-is-being-used","title":"Keeping track of where given register is being used","text":"<p><code>bartiq</code> operates purely on ports and connections between routines and hence does not have a concept of persistent qubits registers which exist beyond a single connection. This gives more flexibility in connecting routines and not having to deal with qubit allocation and deallocation. However, it also means that it is not natively possible to query whether the qubits referenced by a given connection correspond to any persistent quantum register or variable.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#bartiq_1","title":"bartiq","text":""},{"location":"reference/#bartiq","title":"bartiq","text":""},{"location":"reference/#bartiq-classes","title":"Classes","text":""},{"location":"reference/#bartiq.CompiledRoutine","title":"CompiledRoutine  <code>dataclass</code>","text":"<p>               Bases: <code>BaseRoutine[T]</code></p>"},{"location":"reference/#bartiq.CompiledRoutine-functions","title":"Functions","text":""},{"location":"reference/#bartiq.CompiledRoutine.filter_ports","title":"filter_ports","text":"<pre><code>filter_ports(\n    directions: Iterable[str],\n) -&gt; dict[str, Port[T]]\n</code></pre> <p>Returns all the ports with given directions</p>"},{"location":"reference/#bartiq.CompiledRoutine.from_qref","title":"from_qref  <code>classmethod</code>","text":"<pre><code>from_qref(\n    qref_obj: AnyQrefType, backend: SymbolicBackend[T]\n) -&gt; CompiledRoutine[T]\n</code></pre> <p>Load <code>CompiledRoutine</code> from a QREF definition, using specified backend for parsing expressions.</p>"},{"location":"reference/#bartiq.CompiledRoutine.to_qref","title":"to_qref","text":"<pre><code>to_qref(backend: SymbolicBackend[T]) -&gt; SchemaV1\n</code></pre> <p>Exports <code>CompiledRoutine</code> to QREF.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>SymbolicBackend[T]</code> <p>backend used to serialize the symbolic expressions.</p> required <p>Returns:</p> Type Description <code>SchemaV1</code> <p>QREF object representing provided routine.</p>"},{"location":"reference/#bartiq.Port","title":"Port  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Class for representing a port in a routine.</p>"},{"location":"reference/#bartiq.PortDirection","title":"PortDirection","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing port direction. This class is used to categorize ports in routines, such as input, output, and through ports.</p> Possible values <ul> <li>input: Represents an input <code>Port</code> for receiving data.</li> <li>output: Represents an output <code>Port</code> for sending data.</li> <li>through: Represents a through <code>Port</code> for passing data without modification.</li> </ul>"},{"location":"reference/#bartiq.ResourceType","title":"ResourceType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing types of resources. This class is used to categorize resources in routines, such as time, energy, qubits, etc.</p> Possible values <ul> <li>additive: Represents an additive resource, such as time or energy.</li> <li>multiplicative: Represents a multiplicative resource, such as qubits or gates.</li> <li>qubits: Represents the number of qubits used in a <code>Routine</code>.</li> <li>other: Represents any other resource type not covered by the above categories.</li> </ul>"},{"location":"reference/#bartiq.Routine","title":"Routine  <code>dataclass</code>","text":"<p>               Bases: <code>BaseRoutine[T]</code></p>"},{"location":"reference/#bartiq.Routine-functions","title":"Functions","text":""},{"location":"reference/#bartiq.Routine.filter_ports","title":"filter_ports","text":"<pre><code>filter_ports(\n    directions: Iterable[str],\n) -&gt; dict[str, Port[T]]\n</code></pre> <p>Returns all the ports with given directions</p>"},{"location":"reference/#bartiq.Routine.from_qref","title":"from_qref  <code>classmethod</code>","text":"<pre><code>from_qref(\n    qref_obj: AnyQrefType, backend: SymbolicBackend[T]\n) -&gt; Routine[T]\n</code></pre> <p>Load <code>Routine</code> from a QREF definition, using specified backend for parsing expressions.</p>"},{"location":"reference/#bartiq.Routine.to_qref","title":"to_qref","text":"<pre><code>to_qref(backend: SymbolicBackend[T]) -&gt; SchemaV1\n</code></pre> <p>Exports Routine to QREF.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>SymbolicBackend[T]</code> <p>backend used to serialize the symbolic expressions.</p> required <p>Returns:</p> Type Description <code>SchemaV1</code> <p>QREF object representing provided routine.</p>"},{"location":"reference/#bartiq-functions","title":"Functions","text":""},{"location":"reference/#bartiq.routine_to_qref","title":"routine_to_qref","text":"<pre><code>routine_to_qref(\n    routine: Routine[T] | CompiledRoutine[T],\n    backend: SymbolicBackend[T],\n) -&gt; SchemaV1\n</code></pre> <p>Exports a Routine or CompiledRoutine object to QREF.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine[T] | CompiledRoutine[T]</code> <p>routine to be exported.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>backend used to serialize the symbolic expressions.</p> required <p>Returns:</p> Type Description <code>SchemaV1</code> <p>QREF object representing provided routine.</p>"},{"location":"reference/#bartiq.compile_routine","title":"compile_routine","text":"<pre><code>compile_routine(\n    routine: SchemaV1 | RoutineV1 | Routine[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    preprocessing_stages: Iterable[\n        PreprocessingStage[T]\n    ] = DEFAULT_PREPROCESSING_STAGES,\n    postprocessing_stages: Iterable[\n        PostprocessingStage[T]\n    ] = DEFAULT_POSTPROCESSING_STAGES,\n    derived_resources: Iterable[DerivedResources] = (),\n    compilation_flags: CompilationFlags | None = None\n) -&gt; CompilationResult[T]\n</code></pre> <p>Performs symbolic compilation of a given routine.</p> <p>In this context, compilation means transforming a routine defined in terms of routine-local variables into one defined in terms of global input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>SchemaV1 | RoutineV1 | Routine[T]</code> <p>routine to be compiled.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>preprocessing_stages</code> <code>Iterable[PreprocessingStage[T]]</code> <p>functions used for preprocessing of a given routine to make sure it can be correctly compiled by Bartiq.</p> <code>DEFAULT_PREPROCESSING_STAGES</code> <code>postprocessing_stages</code> <code>Iterable[PostprocessingStage[T]]</code> <p>functions used for postprocessing of a given routine after compilation is done.</p> <code>DEFAULT_POSTPROCESSING_STAGES</code> <code>derived_resources</code> <code>Iterable[DerivedResources]</code> <p>iterable with dictionaries describing how to calculate derived resources. Each dictionary should contain the derived resource's name, type and the function mapping a routine to the value of resource.</p> <code>()</code> <code>compilation_flags</code> <code>CompilationFlags | None</code> <p>bitwise combination of compilation flags to tailor the compilation process; access these through the <code>CompilationFlags</code> object. By default None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BartiqCompilationError</code> <p>if the routine is not valid, or if the verification step fails.</p>"},{"location":"reference/#bartiq.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    compiled_routine: CompiledRoutine[T],\n    assignments: Assignments[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    functions_map: FunctionsMap[T] | None = None\n) -&gt; EvaluationResult[T]\n</code></pre> <p>Substitutes variables into compiled routine.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_routine</code> <code>CompiledRoutine[T]</code> <p>a compiled routine to be evaluated.</p> required <code>assignments</code> <code>Assignments[T]</code> <p>a dictionary mapping a subset of input params of <code>compiled_routine</code> either into concrete values, or other expressions. Expressions can be provided either as concrete instances of symbolic expressions understood by backend, or via strings, e.g. `{\"N\": 2, \"M\": \"k+3\"}.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>functions_map</code> <code>FunctionsMap[T] | None</code> <p>a dictionary mapping function names to their concrete implementations.</p> <code>None</code> <p>Returns:</p> Type Description <code>EvaluationResult[T]</code> <p>A new instance of CompiledRoutine with appropriate substitutions made.</p>"},{"location":"reference/#bartiqanalysis","title":"bartiq.analysis","text":""},{"location":"reference/#bartiq.analysis","title":"bartiq.analysis","text":"<p>The bartiq analysis module provides methods to manipulate symbolic expressions.</p>"},{"location":"reference/#bartiq.analysis-functions","title":"Functions","text":""},{"location":"reference/#bartiq.analysis.sympy_rewriter","title":"sympy_rewriter","text":"<pre><code>sympy_rewriter(\n    expression: str | Expr,\n) -&gt; SympyExpressionRewriter\n</code></pre> <p>Initialize a Sympy rewriter instance.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str | Expr</code> <p>An expression to rewrite, either str or sympy.Expr.</p> required <p>Returns:</p> Type Description <code>SympyExpressionRewriter</code> <p>An instance of the SympyExpressionRewriter.</p>"},{"location":"reference/#bartiqanalysisrewriters","title":"bartiq.analysis.rewriters","text":""},{"location":"reference/#bartiq.analysis.rewriters.expression","title":"bartiq.analysis.rewriters.expression","text":"<p>Base classes for rewriting symbolic expressions.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression-classes","title":"Classes","text":""},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter","title":"ExpressionRewriter  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>An abstract base class for rewriting expressions.</p> <p>Attributes:</p> Name Type Description <code>expression</code> <code>T</code> <p>The expression of interest.</p> <code>_original_expression</code> <code>T</code> <p>Private attribute to store the original expression with no modifications. On initialisation, should be set to equal self.expression.</p> <code>backend</code> <code>SymbolicBackend[T]</code> <p>Which symbolic backend to use.</p> <code>linked_symbols</code> <code>dict[str, Iterable[str]]</code> <p>A dictionary of symbols that have been substituted in place of others. Helpful for tracking substitutions.</p> <code>_previous</code> <code>tuple[Instruction, Self | None]</code> <p>The tuple of the most recent <code>Instruction</code> applied and the rewriter instance it was applied to. By default (Initial(), None).</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter-attributes","title":"Attributes","text":""},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.assumptions","title":"assumptions  <code>property</code>","text":"<pre><code>assumptions: tuple[Assumption, ...]\n</code></pre> <p>Return all assumptions applied to this instance, in the order they were applied.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.substitutions","title":"substitutions  <code>property</code>","text":"<pre><code>substitutions: tuple[Substitution, ...]\n</code></pre> <p>Return all substitutions applied to this instance, in the order they were applied.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.original","title":"original  <code>property</code>","text":"<pre><code>original: Self\n</code></pre> <p>Return a rewriter with the original expression, and no modifications.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.free_symbols","title":"free_symbols  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>free_symbols: Iterable[T]\n</code></pre> <p>Return the free symbols in the expression.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.individual_terms","title":"individual_terms  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>individual_terms: Iterable[T]\n</code></pre> <p>Return the expression as an iterable of individual terms.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter-functions","title":"Functions","text":""},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.history","title":"history","text":"<pre><code>history() -&gt; list[Instruction]\n</code></pre> <p>Show a chronological history of all rewriter-transforming commands that have resulted in this instance of the rewriter.</p> <p>Returns:</p> Type Description <code>list[Instruction]</code> <p>A list of chronologically ordered <code>Instructions</code>, where index 0 corresponds to initialisation.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.undo_previous","title":"undo_previous","text":"<pre><code>undo_previous(num_operations_to_undo: int = 1) -&gt; Self\n</code></pre> <p>Undo a number of previous operations.</p> <p>Rewinds the rewriter back to a previous instance.</p> <p>Parameters:</p> Name Type Description Default <code>num_operations_to_undo</code> <code>int</code> <p>The number of previous steps to undo, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Self</code> <p>A previous instance of the rewriter.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.evaluate_expression","title":"evaluate_expression","text":"<pre><code>evaluate_expression(\n    assignments: Mapping[str, TExpr[T]],\n    functions_map: (\n        Mapping[str, Callable[[TExpr[T]], TExpr[T]]] | None\n    ) = None,\n) -&gt; TExpr[T]\n</code></pre> <p>Temporarily evaluate the expression.</p> <p>This method does not store the result, and employs the 'substitute' method of the given backend.</p> <p>Parameters:</p> Name Type Description Default <code>assignments</code> <code>Mapping[str, TExpr[T]]</code> <p>A mapping of symbols to numeric values or expressions.</p> required <code>functions_map</code> <code>Mapping[str, Callable[[TExpr[T]], TExpr[T]]] | None</code> <p>A mapping for user-defined functions in the expressions. By default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TExpr[T]</code> <p>The expression with the evaluations applied.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.focus","title":"focus  <code>abstractmethod</code>","text":"<pre><code>focus(symbols: str | Iterable[str]) -&gt; T\n</code></pre> <p>Return an expression containing terms that involve specific symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>str | Iterable[str]</code> <p>The symbols to focus on.</p> required <p>Returns:</p> Type Description <code>T</code> <p>Subexpression of the overall expression, such that each term contains at least one of the input symbols.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.expand","title":"expand","text":"<pre><code>expand() -&gt; Self\n</code></pre> <p>Expand all brackets in the expression.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.simplify","title":"simplify","text":"<pre><code>simplify() -&gt; Self\n</code></pre> <p>Run the backend `simplify' functionality.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.assume","title":"assume","text":"<pre><code>assume(assumption: str | Assumption) -&gt; Self\n</code></pre> <p>Add an assumption for a symbol.</p> <p>Parameters:</p> Name Type Description Default <code>assumption</code> <code>str | Assumption</code> <p>Either <code>str</code> in the form <code>X &gt; a</code> where <code>X</code> is a symbol or subexpression, and <code>a</code> is a scalar value; or <code>Assumption</code> dataclass. Valid comparators are <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>.</p> required"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.reapply_all_assumptions","title":"reapply_all_assumptions","text":"<pre><code>reapply_all_assumptions() -&gt; Self\n</code></pre> <p>Reapply all previously applied assumptions.</p>"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.substitute","title":"substitute","text":"<pre><code>substitute(expr: str, replace_with: str) -&gt; Self\n</code></pre> <p>Substitute a symbol or subexpression for another symbol or subexpression.</p> <p>By default performs a one-to-one mapping. If a symbol in <code>expr</code> is prefaced with <code>$</code>, it is flagged as a wild symbol. Wild symbols match anything except zero values. These allow for global pattern substitutions, rather than one-to-one substitutions.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The (sub)expression to substitute.</p> required <code>replace_with</code> <code>str</code> <p>The replacement (sub)expression to substitute in.</p> required"},{"location":"reference/#bartiq.analysis.rewriters.expression.ExpressionRewriter.with_instructions","title":"with_instructions","text":"<pre><code>with_instructions(\n    instructions: Sequence[Instruction],\n) -&gt; Self\n</code></pre> <p>Apply a sequence of instructions.</p> <p>Sequentially apply each instruction in the provided list to the expression, with each instruction being applied to the result of the previous one.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>Sequence[Instruction]</code> <p>A list of Instructions to apply in order. Each instruction will be applied to the result of the previous instruction.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A new ExpressionRewriter instance with all instructions applied.</p> <p>Examples:</p> <p>Apply expand, simplify, and an assumption:</p> <pre><code>&gt;&gt;&gt; rewriter.with_instructions(\n...     [Expand(), Simplify(), Assumption(\"x&gt;0\")]\n... )\n</code></pre>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression","title":"bartiq.analysis.rewriters.sympy_expression","text":"<p>A rewriter class for SymPy expressions.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression-classes","title":"Classes","text":""},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter","title":"SympyExpressionRewriter  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionRewriter[Expr]</code></p> <p>Rewrite SymPy expressions.</p> <p>This class accepts a SymPy expression as input, and provides methods for efficient simplification / rewriting of the input expression.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter-attributes","title":"Attributes","text":""},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter.original","title":"original  <code>property</code>","text":"<pre><code>original: Self\n</code></pre> <p>Return a rewriter with the original expression, and no modifications.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter-functions","title":"Functions","text":""},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter.get_symbol","title":"get_symbol","text":"<pre><code>get_symbol(symbol_name: str) -&gt; Symbol | None\n</code></pre> <p>Get the SymPy Symbol object, given the Symbol's name.</p> <p>If the symbol does not exist in the expression, return None.</p> <p>Parameters:</p> Name Type Description Default <code>symbol_name</code> <code>str</code> <p>Name of the symbol.</p> required <p>Returns:</p> Type Description <code>Symbol | None</code> <p>A SymPy Symbol object, or None.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter.focus","title":"focus","text":"<pre><code>focus(symbols: str | Iterable[str]) -&gt; Expr | None\n</code></pre> <p>Focus on specific symbol(s), by only showing terms in the expression that include the input symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>str | Iterable[str]</code> <p>symbol name(s) to focus on.</p> required <p>Returns:</p> Type Description <code>Expr | None</code> <p>A SymPy expression whose terms include the input symbols. If none are found, returns None.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter.all_functions_and_arguments","title":"all_functions_and_arguments","text":"<pre><code>all_functions_and_arguments() -&gt; set[Expr]\n</code></pre> <p>Get a set of all unique functions and their arguments in the expression.</p> <p>The returned set will include all functions at every level of the expression, i.e.</p> <p>All functions and arguments of the following expression: <pre><code>max(a, 1 - max(b, 1 - max(c, lamda)))\n</code></pre> would be returned as: <pre><code>{\n    Max(c, lamda),\n    Max(b, 1 - Max(c, lamda)),\n    Max(a, 1 - Max(b, 1 - Max(c, lamda)))\n}\n</code></pre></p> <p>Returns:</p> Type Description <code>set[Expr]</code> <p>A set of unique functions that exist in the expression.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.SympyExpressionRewriter.list_arguments_of_function","title":"list_arguments_of_function","text":"<pre><code>list_arguments_of_function(\n    function_name: str,\n) -&gt; list[tuple[Expr, ...] | Expr]\n</code></pre> <p>Return a list of arguments X, such that each <code>function_name(x)</code> (for x in X) exists in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>function_name</code> <code>str</code> <p>function name to return the arguments of.</p> required <p>Returns:</p> Type Description <code>list[tuple[Expr, ...] | Expr]</code> <p>A list of arguments of the input function.     If the function takes multiple arguments, they are returned as a tuple in the order they appear.</p>"},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression-functions","title":"Functions","text":""},{"location":"reference/#bartiq.analysis.rewriters.sympy_expression.sympy_rewriter","title":"sympy_rewriter","text":"<pre><code>sympy_rewriter(\n    expression: str | Expr,\n) -&gt; SympyExpressionRewriter\n</code></pre> <p>Initialize a Sympy rewriter instance.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str | Expr</code> <p>An expression to rewrite, either str or sympy.Expr.</p> required <p>Returns:</p> Type Description <code>SympyExpressionRewriter</code> <p>An instance of the SympyExpressionRewriter.</p>"},{"location":"reference/#bartiqcompilation","title":"bartiq.compilation","text":""},{"location":"reference/#bartiq.compilation","title":"bartiq.compilation","text":"<p>The compilation submodule contains routine compilation functionality.</p>"},{"location":"reference/#bartiq.compilation-classes","title":"Classes","text":""},{"location":"reference/#bartiq.compilation.CompilationFlags","title":"CompilationFlags","text":"<p>               Bases: <code>Flag</code></p> <p>A collection of compilation flags to modify <code>compile_routine</code> functionality.</p>"},{"location":"reference/#bartiq.compilation.CompilationFlags-attributes","title":"Attributes","text":""},{"location":"reference/#bartiq.compilation.CompilationFlags.EXPAND_RESOURCES","title":"EXPAND_RESOURCES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPAND_RESOURCES = auto()\n</code></pre> <p>Expand resource values into full, rather than transitive, expressions.</p>"},{"location":"reference/#bartiq.compilation.CompilationFlags.SKIP_VERIFICATION","title":"SKIP_VERIFICATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SKIP_VERIFICATION = auto()\n</code></pre> <p>Skip the verification step on the routine.</p>"},{"location":"reference/#bartiq.compilation.CompilationResult","title":"CompilationResult  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Datastructure for storing results of the compilation.</p> <p>Attributes:</p> Name Type Description <code>routine</code> <code>CompiledRoutine[T]</code> <p>compiled routine</p> <code>_backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p>"},{"location":"reference/#bartiq.compilation.CompilationResult-functions","title":"Functions","text":""},{"location":"reference/#bartiq.compilation.CompilationResult.to_qref","title":"to_qref","text":"<pre><code>to_qref() -&gt; SchemaV1\n</code></pre> <p>Converts <code>routine</code> to QREF using <code>_backend</code>.</p>"},{"location":"reference/#bartiq.compilation.EvaluationResult","title":"EvaluationResult  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Datastructure for storing results of the evaluation.</p> <p>Attributes:</p> Name Type Description <code>routine</code> <code>CompiledRoutine[T]</code> <p>evaluated routine</p> <code>_backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p>"},{"location":"reference/#bartiq.compilation.EvaluationResult-functions","title":"Functions","text":""},{"location":"reference/#bartiq.compilation.EvaluationResult.to_qref","title":"to_qref","text":"<pre><code>to_qref() -&gt; SchemaV1\n</code></pre> <p>Converts <code>routine</code> to QREF using <code>_backend</code>.</p>"},{"location":"reference/#bartiq.compilation-functions","title":"Functions","text":""},{"location":"reference/#bartiq.compilation.compile_routine","title":"compile_routine","text":"<pre><code>compile_routine(\n    routine: SchemaV1 | RoutineV1 | Routine[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    preprocessing_stages: Iterable[\n        PreprocessingStage[T]\n    ] = DEFAULT_PREPROCESSING_STAGES,\n    postprocessing_stages: Iterable[\n        PostprocessingStage[T]\n    ] = DEFAULT_POSTPROCESSING_STAGES,\n    derived_resources: Iterable[DerivedResources] = (),\n    compilation_flags: CompilationFlags | None = None\n) -&gt; CompilationResult[T]\n</code></pre> <p>Performs symbolic compilation of a given routine.</p> <p>In this context, compilation means transforming a routine defined in terms of routine-local variables into one defined in terms of global input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>SchemaV1 | RoutineV1 | Routine[T]</code> <p>routine to be compiled.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>preprocessing_stages</code> <code>Iterable[PreprocessingStage[T]]</code> <p>functions used for preprocessing of a given routine to make sure it can be correctly compiled by Bartiq.</p> <code>DEFAULT_PREPROCESSING_STAGES</code> <code>postprocessing_stages</code> <code>Iterable[PostprocessingStage[T]]</code> <p>functions used for postprocessing of a given routine after compilation is done.</p> <code>DEFAULT_POSTPROCESSING_STAGES</code> <code>derived_resources</code> <code>Iterable[DerivedResources]</code> <p>iterable with dictionaries describing how to calculate derived resources. Each dictionary should contain the derived resource's name, type and the function mapping a routine to the value of resource.</p> <code>()</code> <code>compilation_flags</code> <code>CompilationFlags | None</code> <p>bitwise combination of compilation flags to tailor the compilation process; access these through the <code>CompilationFlags</code> object. By default None.</p> <code>None</code> <p>Raises:</p> Type Description <code>BartiqCompilationError</code> <p>if the routine is not valid, or if the verification step fails.</p>"},{"location":"reference/#bartiq.compilation.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    compiled_routine: CompiledRoutine[T],\n    assignments: Assignments[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    functions_map: FunctionsMap[T] | None = None\n) -&gt; EvaluationResult[T]\n</code></pre> <p>Substitutes variables into compiled routine.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_routine</code> <code>CompiledRoutine[T]</code> <p>a compiled routine to be evaluated.</p> required <code>assignments</code> <code>Assignments[T]</code> <p>a dictionary mapping a subset of input params of <code>compiled_routine</code> either into concrete values, or other expressions. Expressions can be provided either as concrete instances of symbolic expressions understood by backend, or via strings, e.g. `{\"N\": 2, \"M\": \"k+3\"}.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>functions_map</code> <code>FunctionsMap[T] | None</code> <p>a dictionary mapping function names to their concrete implementations.</p> <code>None</code> <p>Returns:</p> Type Description <code>EvaluationResult[T]</code> <p>A new instance of CompiledRoutine with appropriate substitutions made.</p>"},{"location":"reference/#bartiqsymbolics","title":"bartiq.symbolics","text":""},{"location":"reference/#bartiq.symbolics","title":"bartiq.symbolics","text":"<p>The symbolics submodule manages all implemented symbolic backends.</p>"},{"location":"reference/#bartiqerrors","title":"bartiq.errors","text":""},{"location":"reference/#bartiq.errors","title":"bartiq.errors","text":""},{"location":"reference/#bartiq.errors-classes","title":"Classes","text":""},{"location":"reference/#bartiq.errors.BartiqPreprocessingError","title":"BartiqPreprocessingError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function pre-processing.</p>"},{"location":"reference/#bartiq.errors.BartiqPostprocessingError","title":"BartiqPostprocessingError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function post-processing.</p>"},{"location":"reference/#bartiq.errors.BartiqCompilationError","title":"BartiqCompilationError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function compilation.</p>"},{"location":"reference/#bartiqintegrations","title":"bartiq.integrations","text":""},{"location":"reference/#bartiq.integrations","title":"bartiq.integrations","text":"<p>The integrations submodule permits LaTeX pretty-printing, and implements Jupyter notebook widgets.</p>"},{"location":"reference/#bartiq.integrations-functions","title":"Functions","text":""},{"location":"reference/#bartiq.integrations.routine_to_latex","title":"routine_to_latex","text":"<pre><code>routine_to_latex(\n    routine: SchemaV1 | RoutineV1,\n    show_non_root_resources: bool = True,\n    paged=False,\n) -&gt; str | list[str]\n</code></pre> <p>Returns a snippet of LaTeX used to render the routine using clear LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>SchemaV1 | RoutineV1</code> <p>The routine to render.</p> required <code>show_non_root_costs</code> <p>If <code>True</code> (default), displays all costs, otherwise only includes costs from the root node.</p> required <p>Returns:</p> Type Description <code>str | list[str]</code> <p>A LaTeX snippet of the routine.</p>"},{"location":"reference/#bartiqtransform","title":"bartiq.transform","text":""},{"location":"reference/#bartiq.transform","title":"bartiq.transform","text":""},{"location":"reference/#bartiq.transform-classes","title":"Classes","text":""},{"location":"reference/#bartiq.transform-functions","title":"Functions","text":""},{"location":"reference/#bartiq.transform.postorder_transform","title":"postorder_transform","text":"<pre><code>postorder_transform(\n    transform: RoutineTransform[T, P]\n) -&gt; RoutineTransform[T, P]\n</code></pre><pre><code>postorder_transform(\n    transform: CompiledRoutineTransform[T, P]\n) -&gt; CompiledRoutineTransform[T, P]\n</code></pre> <pre><code>postorder_transform(transform)\n</code></pre> <p>Given a callable mapping a routine to a routine, expand it to transform hierarchical graph in postorder fashion.</p> <p>This function is overloaded to handle different types of routines:</p> <ul> <li>RoutineTransform: For working with <code>Routine</code> objects</li> <li>CompiledRoutineTransform: For working with <code>CompiledRoutine</code> objects</li> </ul> <p>Both overloads follow the same pattern: they traverse the hierarchical graph in postorder, applying the transform to each child before applying it to the parent.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <p>A function accepting a routine and a symbolic backend and returning a new routine.       The function signature varies based on the overload:</p> <ul> <li>For <code>Routine</code> objects: <code>(Routine[T], SymbolicBackend[T], *args, **kwargs) -&gt; Routine[T]</code></li> <li>For <code>CompiledRoutine</code> objects: <code>(CompiledRoutine[T], SymbolicBackend[T],                 *args, **kwargs) -&gt; CompiledRoutine[T]</code></li> </ul> required <p>Returns:</p> Type Description <p>A function with the same signature as <code>transform</code>. The function works by traversing         the hierarchical graph in postorder, applying <code>transform</code> to each child before         applying it to the parent.</p> Note <p>The postorder traversal ensures that child routines are processed before their parents, which is essential for bottom-up transformations where parent behavior depends on the transformed children.</p>"},{"location":"reference/#bartiq.transform.add_aggregated_resources","title":"add_aggregated_resources","text":"<pre><code>add_aggregated_resources(\n    routine: CompiledRoutine[T],\n    aggregation_dict: AggregationDict[T],\n    remove_decomposed: bool = True,\n    backend: SymbolicBackend[T] = BACKEND,\n) -&gt; CompiledRoutine[T]\n</code></pre> <p>Add aggregated resources to bartiq <code>routine</code> based on the aggregation dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>CompiledRoutine[T]</code> <p>The program to which the resources will be added.</p> required <code>aggregation_dict</code> <code>AggregationDict[T]</code> <p>A dictionary that decomposes resources into more fundamental components along with their</p> required <code>remove_decomposed</code> <p>Whether to remove the decomposed resources from the routine. Defaults to True.</p> <code>True</code> <code>backend</code> <p>Backend instance to use for handling expressions. Defaults to <code>sympy_backend</code>.</p> <code>BACKEND</code> <p>Returns:</p> Type Description <code>CompiledRoutine[T]</code> <p>The routine with aggregated resources added.</p>"},{"location":"reference/#bartiq.transform.add_circuit_volume","title":"add_circuit_volume","text":"<pre><code>add_circuit_volume(\n    routine: CompiledRoutine[T],\n    name_of_aggregated_t: str = \"aggregated_t_gates\",\n    name_of_qubit_highwater: str = \"qubit_highwater\",\n    backend: SymbolicBackend[T] = BACKEND,\n) -&gt; CompiledRoutine[T]\n</code></pre> <p>Add a 'circuit_volume' resource to a routine and its children.</p> This is calculated as <p>circuit_volume = aggregated_t_gates * qubit_highwater</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>CompiledRoutine[T]</code> <p>The compiled routine to which the resource will be added.</p> required <code>name_of_aggregated_t</code> <code>str</code> <p>Name of the resource representing the number of T gates (default: 'aggregated_t_gates').</p> <code>'aggregated_t_gates'</code> <code>name_of_qubit_highwater</code> <code>str</code> <p>Name of the resource representing the qubit highwater mark</p> <code>'qubit_highwater'</code> <code>(default</code> <p>'qubit_highwater').</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>Symbolic backend to use for symbolic operations.</p> <code>BACKEND</code> <p>Returns:</p> Type Description <code>CompiledRoutine[T]</code> <p>CompiledRoutine[T]: The routine with the 'circuit_volume' resource added to each subroutine.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Debugging <code>bartiq</code> is not always straightforward, so please see below for a number of best practices and common issues:</p> <ul> <li> <p>Routines can get pretty complicated very quickly, especially if nested subroutines are involved. Therefore when you get an error, try isolating the issue and work on a smaller example:</p> <ul> <li>First make sure that each child subroutine compiles correctly on its own. If not, this might suggest where the issue is.</li> <li>Try removing all the unnecessary fields, children, connections, etc. and prepare a minimal failing example.</li> </ul> </li> <li> <p>Take a look at the list of issues on GitHub\u00a0\u29c9 and see if other users have a similar problem!</p> <ul> <li>If not, consider creating one!</li> <li>Submitting issues is the most transparent way to give us feedback \u2013 even if something works, but is extremely unintuitive, we want to make it easier to use. The goal of this tool is to save you time, not waste it on unhelpful error messages.</li> </ul> </li> </ul>"},{"location":"concepts/compilation/","title":"Compilation","text":"<p>Here we will describe how the compilation process in <code>bartiq</code> works. Please keep in mind, that while we try to keep this page up-to-date, in the end the code is the only source-of-truth. If you notice any discrepancies between what is described here and how <code>bartiq</code> behaves, please create an issue\u00a0\u29c9!</p>"},{"location":"concepts/compilation/#birds-eye-perspective-on-compilation","title":"Bird's eye perspective on compilation","text":"<p>Compilation is a very overloaded word, so let us start by explaining what we mean by compiling a routine in <code>bartiq</code>.</p> <p>Quantum programs are often deeply nested structures. A program can call multiple routines, which themselves call other routines, and so on. One typically defines resources of each routine at the local level using locally defined symbols and variables. However, in the end, we are typically interested in resources used by each routine expressed in terms of input parameters of the whole program.</p> <p>Here's an example to illustrate what we're talking about. Below we show a routine with two children, each of them having some example resource defined in terms of their local parameters.</p> <pre><code>version: v1\nprogram:\n  name: root\n  input_params:\n  - N\n  ports:\n  - {\"name\": \"in_0\", \"size\": \"N\", \"direction\": \"input\"}\n  - {\"name\": \"out_0\", \"size\": null, \"direction\": \"output\"}\n  resources:\n  - {\"name\": \"x\", \"value\": \"a.x + b.x\", \"type\": \"additive\"}\n  children:\n    - name: \"a\"\n      ports:\n      - {\"name\": \"in_0\", \"size\": \"L\", \"direction\": \"input\"}\n      - {\"name\": \"out_0\", \"size\": \"2 * L\", \"direction\": \"output\"}\n      resources:\n      - {\"name\": \"x\", \"value\": \"L**2\", \"type\": \"additive\"}\n    - name: \"b\"\n      ports:\n      - {\"name\": \"in_0\", \"size\": \"L\", \"direction\": \"input\"}\n      - {\"name\": \"out_0\", \"size\": \"2 * L\", \"direction\": \"output\"}\n      resources:\n      - {\"name\": \"x\", \"value\": \"L ** 2\", \"type\": \"additive\"}\n  connections:\n    - in_0 -&gt; a.in_0\n    - a.out_0 -&gt; b.in_0\n    - b.out_0 -&gt; out_0  \n</code></pre> <p></p> <p>As we can see, both <code>a</code> and <code>b</code> have a resource <code>x</code> defined relatively to their input port size <code>L</code>. However, when looked globally, those resources would have a different value. Indeed, let's see how the port sizes propagate.</p> <ol> <li>The input port of the top-level <code>root</code> routine of size <code>N</code> is connected to the input port of routine <code>a</code>. Hence,    when viewed through global scope, the input port of <code>a</code> has size <code>N</code>.</li> <li>The output port of routine <code>a</code> has, by definition, size twice as large as its input port. It is connected to input port    of routine <code>b</code>, and therefore <code>b.in_0</code> has size <code>2N</code>.</li> </ol> <p>Looking at the resources of <code>a</code> and <code>b</code> we see that <code>x</code> is defined as square of their respective input port sizes. Thus, <code>a.x</code> has value of <code>N ** 2</code>, and <code>b.x</code> has value <code>(2 * N) ** 2 = 4 * N ** 2</code>.</p> <p>This is what the compilation process is all about. Given a routine with all its components defined in terms of local symbols and parameters, <code>bartiq</code> produces a compiled routine in which all port sizes and resources are defined in terms of the global input symbols of top-level routine.</p>"},{"location":"concepts/compilation/#compilation-in-details","title":"Compilation in details","text":"<p>Compilation can be viewed as recursive process. At every recursive call, several things need to happen in correct order. Below we outline how the compilation proceeds.</p>"},{"location":"concepts/compilation/#step-1-preprocessing","title":"Step 1: Preprocessing","text":"<p>The <code>bartiq</code>'s compilation engine makes several assumptions about the routine being compiled, which simplify its code at the expense of flexibility. For instance, <code>bartiq</code> assumes all port sizes are single parameters of size <code>#port_name</code>. Another (very important) assumption is that there are no parameter links reaching deeper than one level of nesting.</p> <p>Writing a <code>Routine</code> conforming to those requirements by hand is possible, but tedious. Instead, <code>bartiq</code> allows for violation of some of its assumptions, and preprocesses the routine so that all the requirements are met.</p> <p>As an example, suppose some port <code>in_0</code> has size <code>1</code>. <code>bartiq</code> replaces this size with <code>#in_0</code>, and then adds a constraint saying that <code>#in_0 = 1</code>.</p> <p>Currently, the  following preprocessing stages take place prior to compilation:</p> <ol> <li>Propagation of linked params. In this stage all linked parameters reaching further than a direct    descendant are converted into a series of direct parameter links. This is useful because you can, for example,    link a parameter from the top-level routine to a parameter arbitrarily deep in the program structure. This is will compile correctly, despite <code>bartiq</code>'s compilation engine requirement on having only direct links.</li> <li>Promotion of unlinked inputs. Compilation cannot handle parameters that are not linked or passed through    connections. To avoid unnecessary compilation errors, <code>bartiq</code> will promote such parameters by linking it to newly introduced input in the parent routine.</li> <li>Introduction of port variables. As discussed above, this step converts all ports so that they have sizes    equal to a single-parameter expression of known name, while also introducing constraints to make sure    that no information is lost in the process.</li> </ol> <p>It is hopefully clear by now that preprocessing allows users to write more concise and readable routines, while at the same time ensuring that strict requirements of the compilation engine are met.</p>"},{"location":"concepts/compilation/#step-2-recursive-compilation-of-routines","title":"Step 2: Recursive compilation of routines","text":"<p>As already mentioned, the compilation process is recursive. During compilation <code>bartiq</code> maintains a parameter map for all of the routine's children. This map gets populated whenever a new piece of information is obtained, and then passed to the recursive call when each child is being compiled.</p> <p>What follows is a high-level, ordered overview of the main compilation process, where information is passed along edges of the routine graph.</p>"},{"location":"concepts/compilation/#step-21-constraint-validation","title":"Step 2.1: Constraint validation","text":"<p>First, <code>bartiq</code> evaluates the constraints introduced in preprocessing. If any of the constraints is violated, a <code>BartiqCompilationError</code> is raised. Constraints that are trivially satisfied are dropped from the system, and other constraints are retained.</p>"},{"location":"concepts/compilation/#step-22-redefining-local-variables","title":"Step 2.2: Redefining local variables","text":"<p>As the next step, local variables of the routine are expressed in terms of variables passed from its parent (this step does nothing for the root routine). As the result, all local variables are expressed in terms of global parameters.</p>"},{"location":"concepts/compilation/#step-23-input-and-through-port-sizes-are-compiled","title":"Step 2.3: Input- and through-port sizes are compiled","text":"<p>For any given routine, input and through ports must have sizes that only depend on local inputs and variables. After each port is compiled, <code>bartiq</code> checks if this port is connected to others in the program. If so, a corresponding entry in parameter map is added. For instance suppose that port <code>in_0</code> got compiled and has now size <code>N</code>. If this port is connected to port <code>in_1</code> of child <code>a</code>, a parameter map for <code>a</code> will contain entry mapping <code>#in_1</code> to <code>N</code>.</p>"},{"location":"concepts/compilation/#step-24-child-traversal","title":"Step 2.4: Child traversal","text":"<p>The children are traversed in topological order, which ensures all required entries in the parameter maps are populated before other children are compiled.</p> <p>Once this step is completed, we can be sure that all resources and ports of each child are expressed in terms of global variables, which is a requirement for the next step.</p>"},{"location":"concepts/compilation/#step-25-propagating-children-resources","title":"Step 2.5 Propagating children resources","text":"<p>Introduces default additive and multiplicative resources. In case these resources are defined for a child or children, but not a parent, this step will add the same resource to each of the higher-level routines, by defining it as a sum (or product) of the resource over all children that define it. In the example we discussed previously, this allows us to skip the definition of <code>x</code> resource in <code>root</code> and instead have it automatically defined by <code>bartiq</code>.</p>"},{"location":"concepts/compilation/#step-26-repetitions","title":"Step 2.6: Repetitions","text":"<p>In case a routine is repeated (i.e. has a non-empty <code>repetition</code> field), its local resource definitions get updated according  to the repetition rules; the repetition specification itself gets updated using the parameter map.</p>"},{"location":"concepts/compilation/#step-27-resource-compilation","title":"Step 2.7: Resource compilation","text":"<p>At this stage each child should have input and through ports defined in terms of global variables, and we can now compile the resources. Parents have their resources updated from the compiled resources of their children.</p> <p>By default, we compile resources transitively such that the resources of a particular routine are defined only in terms of the relevant contributions from their immedite children, and any expressions defined locally. For instance, an additive resource <code>X</code> in a routine <code>Parent</code> might have the following value after compilation: <pre><code>Parent.resources['X'].value = Child_a.X + Child_b.X + Child_c.X\n</code></pre> This provides a performance boost when routines have multiple routines and subroutines, and expressions become unweildy. </p> <p>To override this, we can pass in a compilation flag into the <code>compile_routine</code> function call: <pre><code>from bartiq.compilation import CompilationFlags\n\ncompile_routine(..., compilation_flags=CompilationFlags.EXPAND_RESOURCES)\n</code></pre> Alternatively, we can call <code>evaluate</code> on the resultant compiled routine with no variable assignments to expand the resources: <pre><code>expanded_resources_routine = evaluate(routine_compiled_transitively, {})\n</code></pre></p>"},{"location":"concepts/compilation/#step-28-output-port-compilation","title":"Step 2.8: Output port compilation","text":"<p>The output ports are compiled, and the new object representing compiled routine is created.</p>"},{"location":"concepts/compilation/#step-29-adding-derived-resources","title":"Step 2.9 Adding derived resources","text":"<p>Finally, derived resources (provided through <code>derived_resources</code> field) are calculated and added to the routine. These resources are not provided in the initial routine (or at least not for all of the subroutines) and need to be calculated based on the existing information.</p>"},{"location":"concepts/compilation/#step-3-postprocessing","title":"Step 3: Postprocessing","text":"<p>After compilation is done, there might be certain operations that the user might want to perform on a compiled routine, e.g.: aggregating resources. Currently, there are no postprocessing steps by default.</p>"},{"location":"concepts/data_format/","title":"Data format","text":""},{"location":"concepts/evaluation/","title":"Evaluation","text":""},{"location":"concepts/rewriters/","title":"Rewriters","text":"<p><code>bartiq</code> includes a set of utilities for manipulating and simplifying symbolic expressions, known as rewriters. This functionality is contained in the <code>analysis</code> submodule, and backend-specific rewriters can be imported directly. <pre><code>from bartiq.analysis import sympy_rewriter\n</code></pre> Here we will give an overview of the rewriting functionality currently implemented, with example usage. This document is intended for advanced users seeking to understand in-depth the logic behind rewriters, either for development or debugging purposes. We will soon have a more usage-oriented tutorial. </p>"},{"location":"concepts/rewriters/#motivation","title":"Motivation","text":"<p>As quantum algorithms increase in complexity their symbolic resource expressions similarly become more complex. For a state of the art algorithm like double factorization the resource expressions can be almost impossible to parse, due to the sheer number of terms and symbols. For example, see Fig. 16 in Even more e\ufb03cient quantum computations of chemistry through tensor hypercontraction, and Eq. C39 for the associated Toffoli cost of this circuit. </p> <p>Making complex expressions more palatable is a primary motivation for rewriters; gaining insights into closed-form expressions for important resource quantities is vital for fault-tolerant quantum algorithm optimization and design.</p>"},{"location":"concepts/rewriters/#overview","title":"Overview","text":"<p>Rewriters are structured as dataclasses with associated methods and properties. Instantiation is done through a factory method; the only required input is an expression that we wish to modify (or rewrite). The input can be provided as a string, or as the backend-specific expression type.</p> <p>While much of the logic is necessarily tied to a particular backend implementation, the base class enforces some core functionality. The philosophy around rewriters is that they should be immutable, such that methods that change an expression actually return a new instance of the rewriter class. This allows for method chaining and easy access to previous expression forms if a change was made in error.</p> <p>Due to the dynamic nature of expression manipulation, rewriters are designed with interactive environments in mind. Rewriters have a <code>_repr_latex_</code> method that prints the current expression, meaning the following code in a Jupyter notebook: <pre><code>sympy_rewriter(\"a + b\")\n</code></pre> would return a $\\LaTeX$ (technically $KaTeX$) expression $a + b$. This, combined with method chaining, means the effect of different methods can be seen immediately.</p> <p>Beyond individual expression manipulation, <code>bartiq</code> also provides functionality to apply rewriter transformations to resources within compiled routines. This allows for systematic simplification of resource expressions across entire quantum algorithms. See Applying Rewriters to Routines for details.</p>"},{"location":"concepts/rewriters/#concepts","title":"Concepts","text":"<p>In designing the rewriter framework we implemented a number of different utility classes. A typical user should not need to interact with these objects directly, but we describe them here for completeness.</p>"},{"location":"concepts/rewriters/#instructions","title":"Instructions","text":"<p>An <code>Instruction</code> is an action that marks a change to an expression. The following <code>Instructions</code> are implemented:</p> <ul> <li> <p><code>Initial</code></p> <p>The initial form of the rewriter instance.</p> </li> <li> <p><code>Simplify</code></p> <p>A backend-specific 'simplify' command.</p> </li> <li> <p><code>Expand</code></p> <p>Expand all brackets in the expression.</p> </li> <li> <p><code>Assumption</code></p> <p>Add an assumption onto a symbol.</p> </li> <li> <p><code>Substitution</code></p> <p>Substitute a symbol or expression for another.</p> </li> <li> <p><code>ReapplyAllAssumptions</code></p> <p>Reapply all previously applied assumptions.</p> </li> </ul> <p>The primary purpose of <code>Instructions</code> is to track the history of an expression, and the user may only ever interact with these objects via the <code>history()</code> method. Of these classes, only <code>Assumption</code> and <code>Substitution</code> require special logic; the others have no methods or attributes implemented. We explore <code>Assumption</code> and <code>Substitution</code> in more detail below.</p> <p>Why not just an <code>Enum</code>?</p> <p>Originally the <code>Instructions</code> were implemented as an <code>Enum</code>! However, because <code>Assumptions</code> and <code>Substitutions</code> required special logic it was challenging to enforce strict typing across both an <code>Enum</code> and other dataclasses. Creating an empty class <code>Instruction</code>, with other classes inheriting from it, resulted in a cleaner implementation.</p>"},{"location":"concepts/rewriters/#assumptions","title":"Assumptions","text":"<p>Assumptions about symbols can be input to the expression, and (in the case of SymPy) the backend symbolic engine attempts to simplify the expression with this new knowledge. An assumption requires three arguments:</p> <ul> <li> <p><code>symbol_name: str</code></p> <p>The symbol to add the assumption to.</p> </li> <li> <p><code>comparator: Comparator | str</code></p> <p>The comparison to apply, one of \"&gt;\", \"&lt;\", \"&gt;=\", \"&lt;=\". </p> </li> <li> <p><code>value: int | float</code></p> <p>The reference value to compare the symbol to.</p> </li> </ul> <p>Alternatively an assumption can be parsed directly from a string: <pre><code>sympy_rewriter(\"max(0, X)\").assume(\"X &gt; 0\")\n&gt;&gt;&gt; X\n</code></pre></p> <p>Given an input assumption to a <code>sympy_rewriter</code>, the symbol is updated with the relevant SymPy predicates\u00a0\u29c9. For some symbol <code>X</code> the predicates we support are:</p> <ul> <li>positive: <code>X &gt; 0</code>,</li> <li>nonnegative: <code>X &gt;= 0</code> or <code>positive</code>,</li> <li>negative: <code>X &lt; 0</code>,</li> <li>nonpositive: <code>X&lt;=0</code> or <code>negative</code>,</li> </ul> <p>From these SymPy is able to deduce other predicates. We do not implement predicates that declare if a symbol belongs to a particular number group, i.e. <code>integer</code>, <code>complex</code>, etc. We found that these kinds of assumptions did little to help simplify expressions. Similarly we do not have support for symbols being declared as infinitely large; if there is a valuable use case for these they could be easily added.</p> <p>There is unfortunately no way to input assumptions between different symbols\u00a0\u29c9. Similarly SymPy does not implement predicates that specify a relationship between a symbol and some nonzero value, i.e. <code>X &gt; 5</code>. However, for this latter point, we have implemented a workaround. </p> <p>If an assumption like <code>X &gt; 5</code> is passed, the following logic occurs:</p> <ul> <li>Predicates are derived for <code>X</code> and applied to the symbol in the expression.</li> <li>A 'dummy' symbol <code>Y</code> is created with the same predicates. </li> <li>We replace <code>X -&gt; Y + 5</code></li> <li>We replace <code>Y -&gt; X - 5</code></li> </ul> <p>The SymPy symbolic engine attempts to simplify the expression at each stage of this process. The drawback is that these kinds of assumptions do not persist. Because SymPy lacks the logic to define the relative value of a symbol beyond (non-)positivity/negativity, after this process the symbol <code>X</code> will only be defined with predicates from that restricted set. As a result, it can occasionally be useful to reapply all previously applied assumptions in order to repeat the steps lined out above. This can be achieved with the <code>reapply_all_assumptions()</code> method. </p> <p>Finally, an assumption can also be applied to an expression with the same logic as above; a dummy symbol is created with the relevant predicates and (temporarily) replaces every instance of the expression.  <pre><code>sympy_rewriter(\n    \"max(0, log(x)) + max(1, log(x)) + max(2, log(x))\"\n).assume(\"log(x) &gt; 2\")\n&gt;&gt;&gt; 3*log(x)\n</code></pre> However any symbols within the expression (<code>x</code> in this example) will not inherit the predicates that were derived for the expression and associated dummy symbol. </p>"},{"location":"concepts/rewriters/#substitutions","title":"Substitutions","text":"<p>Substitutions are another powerful way of simplifying expressions. Rewriters support generic one-to-one substitutions: </p> <ul> <li> <p>symbol to symbol:</p> <pre><code>sympy_rewriter(\"a\").substitute(expr=\"a\", replace_with=\"b\")\n&gt;&gt;&gt; b\n</code></pre> </li> <li> <p>symbol to expression:</p> <pre><code>sympy_rewriter(\"a\").substitute(\"a\", \"b + c\")\n&gt;&gt;&gt; b + c\n</code></pre> </li> <li> <p>expression to symbol:</p> <pre><code>sympy_rewriter(\"a + b\").substitute(\"a + b\", \"c\")\n&gt;&gt;&gt; c\n</code></pre> </li> <li> <p>expression to expression:</p> <pre><code>sympy_rewriter(\"a + b\").substitute(\"a + b\", \"c/d\")\n&gt;&gt;&gt; c/d\n</code></pre> </li> </ul> <p>There are no restrictions on the kind of replacements that can be done. Substitutions can only be passed in via strings in order to unify the API interface.</p> <p>For <code>sympy_rewriter</code>, we also support wildcard substitutions. SymPy has <code>Wild</code> symbols\u00a0\u29c9 which can be used to match patterns in expressions. When using <code>.substitute</code>, a symbol prefaced with <code>$</code> will be marked as <code>Wild</code>, and will match anything that is nonzero. <code>Wild</code> symbols that are permitted to be zero can result in unusual, and often unwanted, behaviour. An example of using wildcard substitutions:</p> <p><pre><code>sympy_rewriter(\"log(x + 2) + log(y + 4)\").substitute(\"log($x + $y)\", \"f(x, y)\")\n&gt;&gt;&gt; f(2, x) + f(4, y)\n</code></pre> If symbols were marked as wild in the first argument to <code>.substitute</code> and then referenced in the second argument, the corresponding matching pattern is used. If a new, or existing, symbol is referenced, it is replaced as-is. If an existing symbol is used as a wild symbol, the corresponding matching pattern takes precedence.  <pre><code># Replace a wild pattern with a new symbol\nsympy_rewriter(\"f(x) + f(y) + z\").substitute(\"f($x)\", \"t\")\n&gt;&gt;&gt; 2*t + z\n\n# Replace a wild pattern with an existing symbol\nsympy_rewriter(\"f(x) + f(y) + z\").substitute(\"f($x)\", \"z\")\n&gt;&gt;&gt; 3*z\n\n# Using an existing symbol as a wild symbol\nsympy_rewriter(\"f(x) + f(y) + z\").substitute(\"f($y)\", \"y\")\n&gt;&gt;&gt; x + y + z\n</code></pre></p> <p>More precise control over wildcard substitutions is possible. Any lowercase symbol prefaced with <code>$</code> will match anything except $0$. An uppercase <code>N</code> will match only numbers. Any other uppercase letter will match only symbols.</p> <pre><code># Match anything\nsympy_rewriter(\n    \"log(1 + x) + log(2 + y) + log(z) + log(t)\"\n).substitute(\"log($x)\", \"x\")\n&gt;&gt;&gt; t + x + y + z + 3\n\n# Match only symbols\nsympy_rewriter(\n    \"log(1 + x) + log(2 + y) + log(z) + log(t)\"\n).substitute(\"log($X)\", \"X\")\n&gt;&gt;&gt; t + z + log(x + 1) + log(y + 2)\n\n# Match symbols and numbers\nsympy_rewriter(\n    \"log(1 + x) + log(2 + y) + log(z) + log(t)\"\n).substitute(\"log($X + $N)\", \"X/N\")\n&gt;&gt;&gt; x + y/2 + log(t) + log(z)\n</code></pre> <p>Finally, it is possible to mix-and-match wild symbols with non-wild symbols: <pre><code>sympy_rewriter(\n    \"a*max(0, x) + b*max(0,y) + a*max(0, y)\"\n).substitute(\"a*max(0, $x)\", \"a*x\")\n&gt;&gt;&gt; a*x + a*y + b*max(0, y)\n</code></pre></p>"},{"location":"concepts/rewriters/#caveats","title":"Caveats","text":"<p>Here we collect some caveats for wildcard substitutions.</p> Matching zero arguments As mentioned we assume that wildcard symbols are nonzero. This is to prevent perfectly valid, but perhaps unwanted, interactions. For example: <pre><code>from sympy.abc import x\nfrom sympy import Wild\na = Wild('a') # Can match to zero values\nb = Wild('b') # Can match to zero values\nexpr = x\nexpr.match(a + b)\n&gt;&gt;&gt; {_a: x, _b: 0}\n</code></pre> While this is correct, if our goal is to only match expressions that are an explicit sum of other expressions, zero-valued <code>Wild</code> symbols can lead to false positives.  Excluding zero-values from wildcard substitutions in rewriters helps prevent these kinds of events, but it can also introduce other pitfalls: <pre><code>rewriter = sympy_rewriter(\"max(0, a) + max(1, b) + max(4, c) + max(5, d)\")\n</code></pre> If we know that our variables <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are all large real values, we can just get rid of the <code>max</code> functions with a wildcard subtitution: <pre><code>rewriter.substitute(\"max($x, $y)\", \"y\")\n&gt;&gt;&gt; max(0, a) + b + c + d\n</code></pre> Because wild symbols cannot be zero, we did not remove the <code>max(0, a)</code> term. To match to zero, you must provide it explicitly: <pre><code>rewriter.substitute(\"max($x, $y)\", \"y\").substitute(\"max(0, $x)\", \"x\")\n&gt;&gt;&gt; a + b + c + d\n</code></pre> Ordering of function arguments Wildcard substitutions can be extremely powerful but, due to a difference between how SymPy stores expressions internally versus how it displays them, can have some unexpected outcomes. Take for instance the following example: <pre><code>rewriter = sympy_rewriter(\"log(x + 2) + log(y + 4)\")\nrewriter\n&gt;&gt;&gt; log(x + 2) + log(y + 4)\nrewriter.substitute(\"log($x + $y)\", \"f(x, y)\")\n&gt;&gt;&gt; f(2, x) + f(4, y)\n</code></pre> Because the expression is displayed with symbols preceding numbers in the `log` arguments, we intutively expect the matching pattern to follow this convention. Instead, it flips their order: this is due to how SymPy prioritises objects in its engine. For more complex arguments it can be difficult to infer in what order SymPy is storing them.  Mix and matching wild/non-wild symbols While mix and matching wild/non-wild symbols is possible, it may not always work as expected. Consider the following SymPy code: <pre><code>from sympy import Wild, Function, symbols, Max\nX = Wild(\"X\")\nY = Wild(\"Y\")\nf = Function(\"f\")\na, b, c = symbols(\"a,b,c\")\n</code></pre> We have defined two <code>Wild</code> symbols <code>X</code> and <code>Y</code> that will match anything, as well as some symbols <code>a</code>, <code>b</code> and <code>c</code>, and a function <code>f</code>.  When attempting to find patterns with <code>Wild</code> symbols, we use the <code>.match</code> method in SymPy. Consider the following interactions.  Case 1: Wildcard substitution works as expected <pre><code>expr = Max(a + b, c)\nexpr.match(Max(X, c))\n&gt;&gt;&gt; {X: a + b}\n</code></pre> Case 2: Wildcard substitution does not work as expected <pre><code>expr = Max(a + b, f(c))\nexpr.match(Max(X, f(c)))\n&gt;&gt;&gt; None\n</code></pre> The only change is now we are trying to match <code>f(c)</code> instead of just <code>c</code>. We intuitively expect this to work, as we are accessing the SymPy objects directly. Naively, we can be tempted to conclude that this change in behaviour is related to the function <code>f</code>.  Case 3: Wildcard substitution works again <pre><code>expr = Max(a, f(c))\nexpr.match(Max(X, f(c)))\n&gt;&gt;&gt; {X: a}\n</code></pre> If we remove <code>+ b</code> from the first argument, the matching works again!   To avoid this unexpected behaviour, it is encouraged to be as explicit as possible and provide more <code>Wild</code> symbols rather than fewer: <pre><code>expr = Max(a + b, f(c))\nexpr.match(Max(X + Y, f(c)))\n&gt;&gt;&gt; {X: a, Y: b}\n</code></pre> As we rely on this SymPy level code when implementing substitutions through rewriters, it is important to keep these kinds of ineractions in mind."},{"location":"concepts/rewriters/#implementation-details","title":"Implementation details","text":"<p>Below we list some of the most important attributes, properties and methods of rewriters. In what follows, the typehint <code>T</code> is used to indicate that the type is backend-dependent expression type. For instance in the <code>sympy_backend</code>, <code>T = sympy.Expr</code>. </p> <p>There are broadly two kinds of methods: those that implement an <code>Instruction</code>, and thus modify the expression, and those that display information about the expression or update it temporarily. Methods that are typehinted to return <code>Self</code> return a new rewriter instance, and thus implement an <code>Instruction</code>.</p>"},{"location":"concepts/rewriters/#attributes","title":"Attributes","text":"<ul> <li> <p><code>expression: T</code></p> <p>The form of the current expression. This is the attribute updated by rewriting methods and displayed by the <code>_repr_latex_</code> method in Jupyter notebooks.</p> <pre><code>sympy_rewriter(\"a + b + c\").expression\n&gt;&gt;&gt; a + b + c\n</code></pre> </li> <li> <p><code>linked_symbols: dict[str, Iterable[str]]</code></p> <p>When substituting one symbol for another, this dictionary tracks the relationships.</p> <pre><code>rewriter = sympy_rewriter(\"a + b + c\").substitute(\"a + b + c\", \"x\")\nrewriter.linked_symbols\n&gt;&gt;&gt; {'x': (\"a\", \"b\", \"c\")}\n</code></pre> </li> </ul>"},{"location":"concepts/rewriters/#properties","title":"Properties","text":"<ul> <li> <p><code>assumptions: tuple[Assumption, ...]</code></p> <p>A tuple of all assumptions that have been applied to the expression, in chronological order.</p> <pre><code>rewriter = (sympy_rewriter(\"a + b + c\")\n            .assume(\"a&gt;5\")\n            .assume(\"b&lt;-1\")\n            .assume(\"c&gt;=10\"))\nrewriter.assumptions\n&gt;&gt;&gt; (\n&gt;&gt;&gt;     Assumption(symbol_name='a', comparator='&gt;', value=5),\n&gt;&gt;&gt;     Assumption(symbol_name='b', comparator='&lt;', value=-1),\n&gt;&gt;&gt;     Assumption(symbol_name='c', comparator='&gt;=', value=10)\n&gt;&gt;&gt; )\n</code></pre> </li> <li> <p><code>substitutions: tuple[Substitution, ...]</code></p> <p>A tuple of all substitutions that have been applied to the expression, in chronological order. <pre><code>rewriter = (sympy_rewriter(\"a\")\n            .substitute(\"a\", \"x\")\n            .substitute(\"x\", \"y\")\n            .substitute(\"y\", \"z\"))\nrewriter.substitutions\n&gt;&gt;&gt; ( \n&gt;&gt;&gt;     Substitution(expr='a', replacement='x', backend='SympyBackend'),\n&gt;&gt;&gt;     Substitution(expr='x', replacement='y', backend='SympyBackend'),\n&gt;&gt;&gt;     Substitution(expr='y', replacement='z', backend='SympyBackend')\n&gt;&gt;&gt; ) \n</code></pre></p> </li> <li> <p><code>original -&gt; Self</code></p> <p>Return the rewritter instance with the original input expression.</p> <pre><code>rewriter = (sympy_rewriter(\"a\")\n            .substitute(\"a\", \"x\")\n            .substitute(\"x\", \"y\")\n            .substitute(\"y\", \"z\"))\nassert rewriter.original == sympy_rewriter(\"a\")\n</code></pre> </li> <li> <p><code>free_symbols -&gt; Iterable[T]</code></p> <p>An iterable of all free symbols (i.e. variables) in the expression.</p> <pre><code>sympy_rewriter(\"a + b + c\").free_symbols\n&gt;&gt;&gt; {a, b, c}\n</code></pre> </li> <li> <p><code>individual_terms -&gt; Iterable[T]</code></p> <p>Return the expression as an iterable of its individual terms. Ordering is not conserved.</p> <pre><code>sympy_rewriter(\"a*b + c*d + e + f*log(1 + g)\").individual_terms\n&gt;&gt;&gt; (\n&gt;&gt;&gt;     e,\n&gt;&gt;&gt;     a*b,\n&gt;&gt;&gt;     c*d,\n&gt;&gt;&gt;     f*log(1 + g),\n&gt;&gt;&gt; )\n</code></pre> </li> </ul>"},{"location":"concepts/rewriters/#methods","title":"Methods","text":"<ul> <li> <p><code>expand() -&gt; Self</code></p> <p>Expand all brackets in the expression.</p> <pre><code>sympy_rewriter(\"(a + b)*c - (d + e)\").expand()\n&gt;&gt;&gt; a*c + b*c - d - e\n</code></pre> </li> <li> <p><code>simplify() -&gt; Self</code></p> <p>Run the backend simplify functionality.</p> <pre><code>sympy_rewriter(\"x*sin(y)**2 + x*cos(y)**2\").simplify()\n&gt;&gt;&gt; x\n</code></pre> <p>As we are calling the SymPy method <code>.simplify</code> on the expression, we encourage the user to read the documentation\u00a0\u29c9 on this functionality.</p> </li> <li> <p><code>assume(assumption: str | Assumption) -&gt; Self</code></p> <p>Add an assumption to the expression. Assumptions can be passed as strings, i.e. <code>x &gt; 0</code>.</p> <pre><code>sympy_rewriter(\"max(5, a)\").assume(\"a &gt; 5\")\n&gt;&gt;&gt; a\n</code></pre> </li> <li> <p><code>substitute(expr: str, replace_with: str) -&gt; Self</code></p> <p>Perform a substitution. As inputs are string only, they will be parsed to the relevant backend. This permits one-to-one substitution as well as pattern matching with wildcards. </p> <p>One-to-one substitution: <pre><code>sympy_rewriter(\"a*b*c\").substitute(\"b*c\", \"y\")\n&gt;&gt;&gt; a*y\n</code></pre></p> <p>Wildcard substitution: <pre><code>sympy_rewriter(\n    \"log(x + 1) + log(y + 4) + log(z + 6)\"\n).substitute(\"log($x + $y)\", \"f(x, y)\")\n&gt;&gt;&gt; f(1, x) + f(4, y) + f(6, z)\n</code></pre></p> </li> <li> <p><code>focus(symbols: str | Iterable[str]) -&gt; T</code></p> <p>Return only terms in the expression that contain the input symbols, grouped if possible. This method only hides other terms, it does not delete them.</p> <pre><code>sympy_rewriter(\"a*b + a*c + a*d + b*e + d*c\").focus(\"a\")\n&gt;&gt;&gt; a*(b + c + d)\n</code></pre> </li> <li> <p><code>evaluate_expression(assignments: dict[str, int | float | T], functions_map: dict[str, Callable]) -&gt; T | int | float</code></p> <p>Assign explicit values to some, or all, of the symbols in the expression. This does not store the result, explicit replacement of symbols with values must be done with <code>substitute</code>. This method calls the <code>backend.substitute</code> method\u00a0\u29c9. </p> <pre><code>sympy_rewriter(\"a\").evaluate_expression(assignments: {\"a\": 10})\n&gt;&gt;&gt; 10\n</code></pre> </li> <li> <p><code>history() -&gt; list[Instruction]</code></p> <p>Return a list of <code>Instruction</code>s that have been applied to this rewriter instance. </p> <pre><code>(sympy_rewriter(\"a + b\")\n    .assume(\"a &gt; 10\")\n    .substitute(\"b\", \"c\")\n    .expand()\n    .simplify()\n    .history())\n&gt;&gt;&gt; [ \n&gt;&gt;&gt;     Initial(),\n&gt;&gt;&gt;     Assumption(symbol_name='a', comparator='&gt;', value=10),\n&gt;&gt;&gt;     Substitution(expr=''b'', replacement='c', backend='SympyBackend'),\n&gt;&gt;&gt;     Expand(),\n&gt;&gt;&gt;     Simplify()\n&gt;&gt;&gt; ]\n</code></pre> </li> <li> <p><code>undo_previous(num_operations_to_undo: int = 1) -&gt; Self</code></p> <p>Undo a number of previous operations applied to this instance.</p> <pre><code>(sympy_rewriter(\"a\")\n    .substitute(\"a\", \"x\")\n    .substitute(\"x\", \"y\")\n    .substitute(\"y\", \"z\")\n    .undo_previous(2))\n&gt;&gt;&gt; x\n</code></pre> </li> <li> <p><code>with_instructions(instructions: Sequence[Instruction]) -&gt; Self</code> {#with_instructions}</p> <p>Apply a sequence of instructions to the rewriter in order. This method provides an alternative to method chaining by allowing you to apply multiple operations with a single method call.</p> <pre><code>from bartiq.analysis.rewriters.utils import Expand, Simplify, Assumption, Substitution\n\ninstructions = [\n    Expand(),\n    Simplify(),\n    Assumption.from_string(\"x &gt; 0\"),\n    Substitution(\"a\", \"b\", backend)\n]\nsympy_rewriter(\"(a + 1) * max(x, 0)\").with_instructions(instructions)\n&gt;&gt;&gt; (b + 1)*x\n</code></pre> <p>This is equivalent to chaining the methods: <pre><code>sympy_rewriter(\"(a + 1) * max(x, 0)\").expand().simplify().assume(\"x &gt; 0\").substitute(\"a\", \"b\")\n&gt;&gt;&gt; (b + 1)*x\n</code></pre></p> </li> </ul>"},{"location":"concepts/rewriters/#sympy-specific-methods","title":"SymPy Specific Methods","text":"<p>While the base class enforces some functionality, SymPy allows us to extend this and implement other helpful methods. The following methods are specific to the SymPy rewriter class.</p> <ul> <li> <p><code>get_symbol(symbol_name: str) -&gt; Symbol | None</code></p> <p>Return a SymPy <code>Symbol</code> from <code>expression</code> given its name. If it doesn't exist, return <code>None</code>.</p> <pre><code>sympy_rewriter(\"a*log(x + b)/d\").get_symbol(\"d\")\n&gt;&gt;&gt; d\n</code></pre> </li> <li> <p><code>all_functions_and_arguments() -&gt; set[Expr]</code></p> <p>Return a set of all functions and their arguments in the <code>expression</code> attribute. This includes nested functions.</p> <pre><code>sympy_rewriter(\n    \"a*log(x + 1) + max(b, max(c, d)) + ceiling(y/z)\"\n).all_functions_and_arguments()\n&gt;&gt;&gt; {\n&gt;&gt;&gt;     log(x + 1),\n&gt;&gt;&gt;     max(c, d),\n&gt;&gt;&gt;     max(b, max(c, d)),\n&gt;&gt;&gt;     ceiling(y, z),\n&gt;&gt;&gt; }\n</code></pre> </li> <li> <p><code>list_arguments_of_function(function_name: str) -&gt; list[tuple[Expr, ...] | Expr]</code></p> <p>Given a function name, return a list of all of its arguments in the <code>expression</code>. If the function takes multiple arguments, they are returned as a tuple in the order they appear.</p> <pre><code>    sympy_rewriter(\n    \"a*log(x + 1) + max(b, max(c, d)) + ceiling(y/z)\"\n).list_arguments_of_function(\"max\")\n&gt;&gt;&gt; [\n&gt;&gt;&gt;     (b, max(c, d)),\n&gt;&gt;&gt;     (c, d),\n&gt;&gt;&gt; ]\n</code></pre> </li> </ul>"},{"location":"concepts/rewriters/#applying-rewriters-to-routines","title":"Applying Rewriters to Routines","text":"<p>Beyond manipulating individual expressions, <code>bartiq</code> provides functionality to apply rewriter instructions to resources within <code>CompiledRoutine</code> objects. This allows you to systematically simplify resource expressions across entire quantum algorithms.</p>"},{"location":"concepts/rewriters/#rewrite_routine_resources","title":"<code>rewrite_routine_resources</code>","text":"<p>The <code>rewrite_routine_resources</code> function applies a sequence of rewriter instructions to specific resources in a <code>CompiledRoutine</code>. This function recursively traverses the routine hierarchy and applies the same transformations to the specified resources at every level.</p> <pre><code>from bartiq.analysis.rewriters.routine_rewriter import rewrite_routine_resources\nfrom bartiq.analysis.rewriters.sympy_expression import sympy_rewriter\nfrom bartiq import compile_routine\n</code></pre> <p>Function signature: <pre><code>rewrite_routine_resources(\n    routine: CompiledRoutine,\n    resources: str | Iterable[str],\n    instructions: list[Instruction],\n    rewriter_factory: ExpressionRewriterFactory = sympy_rewriter,\n) -&gt; CompiledRoutine\n</code></pre></p> <p>Example usage: <pre><code># Assume we have a compiled routine with complex resource expressions\ncompiled_routine = compile_routine(my_routine).routine\n\n# Create a rewriter with the transformations we want to apply\nexample_rewriter = sympy_rewriter(compiled_routine.resource_values[\"toffoli_count\"])\ntransformations = (\n    example_rewriter\n    .assume(\"n &gt; 100\")\n    .assume(\"eps &lt; 0.01\")\n    .simplify()\n    .substitute(\"log2(1/eps)\", \"precision_bits\")\n    .history()\n)\n\n# Apply these transformations to all \"toffoli_count\" resources in the routine\nsimplified_routine = rewrite_routine_resources(\n    compiled_routine,\n    resources=\"toffoli_count\",\n    instructions=transformations\n)\n\n# Or apply to multiple resources at once\nsimplified_routine = rewrite_routine_resources(\n    compiled_routine,\n    resources=[\"toffoli_count\", \"t_count\", \"qubit_count\"],\n    instructions=transformations\n)\n</code></pre></p>"},{"location":"concepts/symbolics/","title":"Symbolics","text":""},{"location":"tutorials/","title":"Introduction","text":"<p>We currently have three tutorials for <code>bartiq</code>:</p> <ul> <li>Basic example</li> <li>Alias Sampling basic</li> <li>Advanced examples</li> </ul> <p>They have been designed to gradually introduce you to the concepts we use in <code>bartiq</code>, so we recommend to go through them in order.</p>"},{"location":"tutorials/01_basic_example/","title":"Basic example","text":"<p>In this tutorial we will work through a toy example of a quantum algorithm and implement it in <code>bartiq</code>.</p> <p>The goal is to give familiarity with the data structures in <code>bartiq</code>; focusing on the most important aspects of the core <code>bartiq</code> classes.</p> <p>As we will see, even complex algorithms employ a similar layout to toy examples like this one, making the jump in abstraction straightforward.</p> <p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>Let's consider the following simple routine:</p> <p></p> <p>In <code>bartiq</code> the basic concept for representing both the whole algorithm as well as all the building blocks is a routine. So what do we know about the routines from the picture above?</p> <ul> <li>Our main routine is called \"my algorithm\"</li> <li>It consists of two subroutines: \"A\" and \"B\".</li> <li>It takes in a register of size \"n\".</li> </ul> <p>How do we express this in <code>bartiq</code>? We do that using the <code>QREF</code> format\u00a0\u29c9 \u2013 a format for expressing algorithms that we developed with QREs in mind. So let's write our first routine:</p> In\u00a0[1]: Copied! <pre>my_algorithm = {\n    \"name\": \"my_algorithm\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": None},\n    ],\n}\n</pre> my_algorithm = {     \"name\": \"my_algorithm\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": None},     ], } <p>What do we have here?</p> <ul> <li><code>name</code>: name of the routine</li> <li><code>type</code>: in this case we don't define the type, but in more complex algorithms you might want to add types, such as \"basic_gate\" or \"comparator\".</li> <li><code>ports</code>: ports define the interface of the routine. The size of the input port is equal to <code>n</code> and in general, we won't know the size of the output port until we perform the compilation.</li> </ul> <p>What are we missing? Children. We have only defined the top level routine, not the subroutines! Let's define the children next.</p> In\u00a0[2]: Copied! <pre>routine_a = {\n    \"name\": \"A\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},\n    ],\n}\n</pre> routine_a = {     \"name\": \"A\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},     ], } <p>Notice that the sizes of input and output ports don't need to match. Here we defined that the size of the output port is twice the size of the input.</p> In\u00a0[3]: Copied! <pre>routine_b = {\n    \"name\": \"B\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},\n        # \"y\" will be defined in the next step\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},\n    ],\n}\n</pre> routine_b = {     \"name\": \"B\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},         # \"y\" will be defined in the next step         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},     ], } <p>We will need to know how much each subroutine costs if we want to run the resource estimation.</p> <p>In fault-tolerant quantum computation a common metric of interest is an algorithm's T-gate count. T-gates are one of the most promising avenues for achieving universal quantum computation, but they typically more expensive to implement than other quantum gates. As such, they are commonly used as the metric for an algorithm's computational cost.</p> <p>In this example, let's say that routine <code>A</code> costs <code>2*n_a + x</code> T gates and routine <code>B</code> costs <code>n_b*ceiling(log2(n_b)) * y</code> T-gates, where <code>x</code> and <code>y</code> are some arbitrary paremeters.</p> <p>Knowing T-gate costs and sizes of parameters, we can now visualize subroutines <code>A</code> and <code>B</code> like this:</p> <p></p> <p>This will require adding two new fields to the dictionaries defining <code>A</code> and <code>B</code> respectively:</p> In\u00a0[4]: Copied! <pre># Define T-gate counts for routine a\nroutine_a[\"input_params\"] = [\"x\"]\nroutine_a[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}]\n\n# Define T-gate counts for routine b\nroutine_b[\"input_params\"] = [\"y\"]\nroutine_b[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceiling(log2(n_b)) * y\"}]\n</pre> # Define T-gate counts for routine a routine_a[\"input_params\"] = [\"x\"] routine_a[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}]  # Define T-gate counts for routine b routine_b[\"input_params\"] = [\"y\"] routine_b[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceiling(log2(n_b)) * y\"}] <p>As you can see we added two new fields to our dictionaries:</p> <ul> <li><code>input_params</code>: which defines the variables used by the routine's resource expressions.</li> <li><code>resources</code>: which defines the resource costs for our routine. As you can see resources have the following fields:<ul> <li><code>name</code>: name of the resource</li> <li><code>type</code>: <code>qref</code> allows for the following types: <code>additive</code>, <code>multiplicative</code>, <code>qubits</code> and <code>other</code>.</li> <li><code>value</code>: expression (or numeric value) defining the cost.</li> </ul> </li> </ul> <p>Now that <code>routine_a</code> and <code>routine_b</code> are complete, we can add the missing components to <code>my_algorithm</code>:</p> In\u00a0[5]: Copied! <pre>my_algorithm[\"children\"] = [routine_a, routine_b]\nmy_algorithm[\"connections\"] = [\n    {\"source\": \"in\", \"target\": \"A.in\"},\n    {\"source\": \"A.out\", \"target\": \"B.in\"},\n    {\"source\": \"B.out\", \"target\": \"out\"},\n]\nmy_algorithm[\"input_params\"] = [\"z\"]\nmy_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}]\n</pre> my_algorithm[\"children\"] = [routine_a, routine_b] my_algorithm[\"connections\"] = [     {\"source\": \"in\", \"target\": \"A.in\"},     {\"source\": \"A.out\", \"target\": \"B.in\"},     {\"source\": \"B.out\", \"target\": \"out\"}, ] my_algorithm[\"input_params\"] = [\"z\"] my_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}] <p>The new things we have here are:</p> <ul> <li><code>connections</code>: defines how routines are connected via their ports. Each connection has source and target.</li> <li><code>children</code>: defines a routine's subroutines.</li> <li><code>linked_params</code>: defines how input parameters used by the parent are linked to the parameters of children. In this case, it specifies that the input parameter <code>z</code> should be passed as <code>x</code> to the subroutine <code>A</code> and as <code>y</code> to <code>B</code>. Note that we don't need to pass information about <code>n</code>, <code>n_a</code> and <code>n_b</code>, as this information gets passed through the connections.</li> </ul> <p>The last step is just a formality to indicate which version of QREF schema we use:</p> In\u00a0[6]: Copied! <pre>my_algorithm_qref_dict = {\"version\": \"v1\", \"program\": my_algorithm}\n</pre> my_algorithm_qref_dict = {\"version\": \"v1\", \"program\": my_algorithm} <p>Since it's more convenient to use a <code>pydantic</code> model rather than raw dictionary, we'll convert it:</p> In\u00a0[7]: Copied! <pre>from qref import SchemaV1\n\nmy_algorithm_qref = SchemaV1(**my_algorithm_qref_dict)\n</pre> from qref import SchemaV1  my_algorithm_qref = SchemaV1(**my_algorithm_qref_dict) <p>So, is there an intuitive way to understand what my algorithm looks like and how the resources are used in each routine? You can use the visualization tool from <code>QREF</code>\u00a0\u29c9 to plot the hierarchical Directed Acyclic Graph (DAG) of the algorithm you wrote.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Then, run: </p> In\u00a0[8]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(my_algorithm_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"my_algorithm\", format=\"png\")\n\n# Render the Graphviz object in the notebook\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(my_algorithm_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"my_algorithm\", format=\"png\")  # Render the Graphviz object in the notebook gv_object Out[8]: <p>In this graph, you can see both subroutines from the original algorithm, along with their <code>names</code> and<code>ports</code>. It provides a general idea of the connectivity between subroutines in the algorithm and shows how information is stored.</p> <p>Below you can find depiction of the uncompiled version of <code>my_algorithm</code>. </p> <p>What does \"uncompiled\" means here?</p> <p>It means that all the costs and register sizes are expressed using local variables (as in the picture above). What does it mean? Look at this:</p> In\u00a0[9]: Copied! <pre>uncompiled_routine = my_algorithm_qref.program\nuncompiled_routine.children.by_name[\"A\"].resources\n</pre> uncompiled_routine = my_algorithm_qref.program uncompiled_routine.children.by_name[\"A\"].resources Out[9]: <pre>[ResourceV1(name='T_gates', type='additive', value='2*n_a + x')]</pre> <p>The cost of <code>A</code> is still expressed in terms of its own \"local\" variables, <code>n_a</code> and <code>x</code>. Information that we included in <code>linked_params</code> has not yet been propagated into <code>A</code>.</p> <p>We also don't know yet what's the size of the output port:</p> In\u00a0[10]: Copied! <pre>uncompiled_routine.ports.by_name[\"out\"]\n</pre> uncompiled_routine.ports.by_name[\"out\"] Out[10]: <pre>PortV1(name='out', direction='output', size=None)</pre> <p>Most importantly, we don't know what is the total cost of the algorithm:</p> In\u00a0[11]: Copied! <pre>uncompiled_routine.resources\n</pre> uncompiled_routine.resources Out[11]: <pre>[]</pre> <p>So what we want to do is to get to the following picture: </p> <p>You can compare it with the previous picture and see how \"local\" variables have been replaced with \"global\" ones.</p> <p>We do this with the following command:</p> In\u00a0[12]: Copied! <pre>from bartiq import compile_routine\n\ncompiled_routine = compile_routine(my_algorithm_qref).routine\n</pre> from bartiq import compile_routine  compiled_routine = compile_routine(my_algorithm_qref).routine <p>Now let's check the same fields of our <code>compiled_routine</code> object:</p> In\u00a0[13]: Copied! <pre>print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value)\nprint(\"Output size:\", compiled_routine.ports[\"out\"].size)\nprint(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value)\n</pre> print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value) print(\"Output size:\", compiled_routine.ports[\"out\"].size) print(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value) <pre>T gates for A: 2*n + z\nOutput size: 2*n + z\nTotal T gates: A.T_gates + B.T_gates\n</pre> <p>Since the resources in the children have type <code>additive</code>, <code>bartiq</code> automatically added the <code>T_gates</code> resource to the parent as a sum of the resources of the children.</p> <p>The reason the total T gates value is represented as a sum of <code>child.resource</code> strings is due to our default compilation process, such that resources are compiled transitively. To override this, we can pass a compilation flag.</p> In\u00a0[14]: Copied! <pre>from bartiq.compilation import CompilationFlags\n\ncompiled_routine = compile_routine(my_algorithm_qref, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine\nprint(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value)\n</pre> from bartiq.compilation import CompilationFlags  compiled_routine = compile_routine(my_algorithm_qref, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine print(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value) <pre>Total T gates: 2*n*z*ceiling(log2(2*n)) + 2*n + z\n</pre> <p>Now it would be good to know what is the cost when we subsitute some numbers. We can do this using the <code>evaluate</code> method.</p> <p>As you can see in the example below, it can either substitute all the parameters or just some of them.</p> In\u00a0[15]: Copied! <pre>from bartiq import evaluate\n\nprint(\"Different values of n:\")\nfor n in range(6, 16, 2):\n    assignments = {\"n\": n}\n    evaluated_routine = evaluate(compiled_routine, assignments).routine\n    print(f\"\\tn = {n}, total #T-gates:\", evaluated_routine.resources[\"T_gates\"].value)\n\nz = 5\nassignments = {\"n\": n, \"z\": z}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\n\nprint(f\"\\nFor (n={n}, z={z}) total #T-gates:\", evaluated_routine.resources[\"T_gates\"].value)\n</pre> from bartiq import evaluate  print(\"Different values of n:\") for n in range(6, 16, 2):     assignments = {\"n\": n}     evaluated_routine = evaluate(compiled_routine, assignments).routine     print(f\"\\tn = {n}, total #T-gates:\", evaluated_routine.resources[\"T_gates\"].value)  z = 5 assignments = {\"n\": n, \"z\": z} evaluated_routine = evaluate(compiled_routine, assignments).routine  print(f\"\\nFor (n={n}, z={z}) total #T-gates:\", evaluated_routine.resources[\"T_gates\"].value) <pre>Different values of n:\n\tn = 6, total #T-gates: 49*z + 12\n\tn = 8, total #T-gates: 65*z + 16\n\tn = 10, total #T-gates: 101*z + 20\n\tn = 12, total #T-gates: 121*z + 24\n\tn = 14, total #T-gates: 141*z + 28\n\nFor (n=14, z=5) total #T-gates: 733\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/01_basic_example/#basic-example","title":"Basic example\u00b6","text":""},{"location":"tutorials/01_basic_example/#compilation","title":"Compilation\u00b6","text":""},{"location":"tutorials/01_basic_example/#evaluation","title":"Evaluation\u00b6","text":""},{"location":"tutorials/01_basic_example/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to construct a simple algorithm to use with <code>bartiq</code></li> <li>How to compile an estimate</li> <li>How to evaluate an estimate</li> <li>How to use the <code>qref</code> visualization tool to visualize an algorithm</li> </ul> <p>In the next tutorial we'll cover how to implement a more complex algorithm from a paper.</p>"},{"location":"tutorials/02_alias_sampling_basic/","title":"Alias Sampling","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or clone the repository and go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>The example we used in previous tutorial was nice to establish some basic terminology. But let's be honest, it was contrived and not very practical. So now we'll take a practical algorithm from a paper and try to get some resource estimations for it using <code>bartiq</code>!</p> <p>We'll use Alias Sampling \u2014-- an algorithm proposed by Babbush et al. in Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity\u00a0\u29c9. This is what the circuit looks like:</p> <p></p> <p>It comes from Fig. 11 from the original paper.</p> <p>This circuit is an important subroutine in the paper's larger algorithm because it is responsible for preparing arbitrary quantum states, which can be thought of as \"loading\" data into the quantum computer.</p> <p>In this tutorial we won't be explaining how the algorithm works in detail \u2014 partly because this is not the place, and partly because Craig Gidney already did it in his blogpost\u00a0\u29c9</p> <p>But briefly and at a high level, Alias Sampling contains the following subroutines:</p> <ul> <li>$\\textrm{UNIFORM}_L$:\u00a0prepares a state which is a uniform superposition over $L$ basis states</li> <li>$H^{\\otimes\\mu}$: applies a set of Hadamard gates to create a uniform superposition over $2^{\\mu}$ basis states</li> <li>QROM: Represented in the second (timelike) layer of our circuit, this subroutine loads data values into two <code>data</code> registers in superposition depending on the state input to $\\textrm{In}_{\\ell}$.</li> <li>Comparator:\u00a0The third timelike layer flips a target qubit if $\\textrm{keep}_l \\leq \\sigma_l$ based on the values of the two other input registers (to $\\textrm{In}_{\\sigma_l}$ and $\\textrm{In}_{\\textrm{keep}_l}$ respectively).</li> <li>Controlled SWAP: swaps two target registers conditional on the value of a control qubit \u2014 in this case, the final register.</li> </ul> <p>Now, before we map all these subroutines to <code>qref</code>, it would be good to know what the costs of each of the subroutines are. After carefully reading the paper we can deduce what the costs are. But before we get there, let's define our symbols to have consistent naming.  The authors use same letters for different variables in different figures, so it can get confusing without reading the paper carefully\u2014that's why we'll stick to the naming from the figure above to keep things simple.</p> <ul> <li>$L$ \u2013\u00a0number of coefficients we want to load.</li> <li>$\\mu$ \u2013 bits of precision for coefficients we load.</li> <li>$k$ \u2013 the exponent of 2 in the prime factorization of $L$. In other words, it is the largest integer such that  $2^k$ divides $L$. This is not a widely-used mathematical operation, but fortunately in <code>bartiq</code> we can use a shorthand for that, and we say that <code>k = multiplicity(2, L)</code>. For more information, you can check how it's defined in sympy\u00a0\u29c9.</li> </ul> <p>Given all that \u2014 what are the costs of our routines? For simplicity, we shall focus on just calculating the T-gate and rotation costs:</p> <ul> <li>Uniform: $8(\\lceil\\log2(L/2^k)\\rceil-1)$ T-gates and 2 rotation gates. It comes Fig 12 and its caption. We omit the $O(\\log(1/\\epsilon)$ term, because it corresponds to those two rotations that we count separately.</li> <li>Hadamards: No T-gates or rotations.</li> <li>QROM: $4L-4$ \u2013 this comes from Fig. 10.</li> <li>Comparator: $4\\mu-4$ \u2013\u00a0this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> <li>Swap: $O(\\log2(L))$ \u2013 this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> </ul> <p>These expressions don't take into account some nuances\u2014for example the uniform state preparation (USP) can be implemented as a layer of Hadamard gates if $L$ is a power of two.</p> <p>Armed with this knowledge, we can now write each individual routine.</p> <p>NOTE:</p> <p>Unfortunately the costs presented in this example are quite complicated. It would be great to just point you to a single place in the paper, get an expression and type it into <code>bartiq</code>.</p> <p>If there are any mistakes or oversimplifications \u2014 please let us know! However, the fact that even a relatively simple routine presents such challenges, shows that we need better tools for working with quantum algorithms.</p> <p>Also, as it turns out in the follow-up work not all the costs from this paper are correct, as some routines can be optimized. But explaining that is way beyond the scope of this tutorial.</p> In\u00a0[1]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"resources\": [\n        {\n            \"name\": \"T_gates\",\n            \"type\": \"additive\",\n            \"value\": \"8*(ceiling(log2(L/(2 ** multiplicity(2,L))))-1)\",\n        },\n        {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log2(L))\"},\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"resources\": [         {             \"name\": \"T_gates\",             \"type\": \"additive\",             \"value\": \"8*(ceiling(log2(L/(2 ** multiplicity(2,L))))-1)\",         },         {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"R\": \"ceiling(log2(L))\"}, } <p>There are two things that we did here which might not be straight-forward.</p> <ul> <li>We used <code>ceiling</code> function for the port size\u2014that's because port sizes need to be integer.</li> <li>We introduced new field: <code>local_variables</code>. This allows us to define some \"helper\" variables, which are only used in the scope of this routine and save us some typing</li> </ul> In\u00a0[2]: Copied! <pre>had_dict = {\n    \"name\": \"had\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},\n    ],\n}\n</pre> had_dict = {     \"name\": \"had\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},     ], } In\u00a0[3]: Copied! <pre>qrom_dict = {\n    \"name\": \"qrom\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],\n    \"input_params\": [\"L\", \"mu\"],\n    \"local_variables\": {\"R\": \"ceiling(log2(L))\"},\n}\n</pre> qrom_dict = {     \"name\": \"qrom\",     \"type\": None,     \"ports\": [         {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],     \"input_params\": [\"L\", \"mu\"],     \"local_variables\": {\"R\": \"ceiling(log2(L))\"}, } In\u00a0[4]: Copied! <pre>compare_dict = {\n    \"name\": \"compare\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],\n    \"input_params\": [\"mu\"],\n}\n</pre> compare_dict = {     \"name\": \"compare\",     \"type\": None,     \"ports\": [         {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],     \"input_params\": [\"mu\"], } In\u00a0[5]: Copied! <pre>swap_dict = {\n    \"name\": \"swap\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log2(X))\"}],\n    \"connections\": [\n        {\"source\": \"In_control\", \"target\": \"out_control\"},\n        {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},\n        {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},\n    ],\n    \"input_params\": [\"X\"],\n}\n</pre> swap_dict = {     \"name\": \"swap\",     \"type\": None,     \"ports\": [         {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log2(X))\"}],     \"connections\": [         {\"source\": \"In_control\", \"target\": \"out_control\"},         {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},         {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},     ],     \"input_params\": [\"X\"], } <p>We follow the same naming convention in all the subroutines to make things easier to follow. But in <code>swap_dict</code>, we decided to use <code>X</code> instead of <code>R=ceiling(log2(L))</code>. Why?</p> <p>It shows that we can use whatever naming we want for any particular subroutine \u2013 we don't need to stick to one convention in all the subroutines. This is what you would often want to do in practice. If you would like to reuse this controlled swap in some other algorithm, a generic <code>X</code> is a much better choice than a very specific <code>R</code>.</p> <p>Now that we have all these defined, let's construct the dictionary for the whole algorithm:</p> In\u00a0[6]: Copied! <pre>alias_sampling_dict = {\n    \"name\": \"alias_sampling\",\n    \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"connections\": [\n        {\"source\": \"In_0\", \"target\": \"usp.in\"},\n        {\"source\": \"In_1\", \"target\": \"had.in\"},\n        {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},\n        {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},\n        {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},\n        {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},\n        {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},\n        {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},\n        {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},\n        {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},\n        {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},\n        {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},\n        {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},\n        {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},\n        {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},\n        {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},\n    ],\n    \"input_params\": [\"mu\", \"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log2(L))\"},\n    \"linked_params\": [\n        {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},\n        {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},\n    ],\n}\n</pre> alias_sampling_dict = {     \"name\": \"alias_sampling\",     \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],     \"type\": None,     \"ports\": [         {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},     ],     \"connections\": [         {\"source\": \"In_0\", \"target\": \"usp.in\"},         {\"source\": \"In_1\", \"target\": \"had.in\"},         {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},         {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},         {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},         {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},         {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},         {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},         {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},         {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},         {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},         {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},         {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},         {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},         {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},         {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},     ],     \"input_params\": [\"mu\", \"L\"],     \"local_variables\": {\"R\": \"ceiling(log2(L))\"},     \"linked_params\": [         {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},         {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},     ], } In\u00a0[7]: Copied! <pre>from qref import SchemaV1\n\nalias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict}\nuncompiled_routine = SchemaV1(**alias_sampling_qref)\n</pre> from qref import SchemaV1  alias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict} uncompiled_routine = SchemaV1(**alias_sampling_qref) <p>Additionally, you can examine how the circuit is represented in <code>qref</code> format by visualizing it.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Once installed, proceed to visualize the representation of the circuit.</p> In\u00a0[8]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(uncompiled_routine)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_sampling\", format=\"png\")\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(uncompiled_routine)  # Render the Graphviz object to a PNG file gv_object.render(\"alias_sampling\", format=\"png\") gv_object Out[8]: <p>As we expected, the diagram displays five subroutines which are <code>usp</code>, <code>qrom</code>, <code>compare</code>, <code>had</code>, <code>swap</code>, and their hierarchical connections. Everything appears to be in order! Let's proceed with the compilation.</p> In\u00a0[\u00a0]: Copied! <pre>from bartiq import compile_routine\nfrom bartiq.compilation import CompilationFlags\n\ncompiled_routine = compile_routine(uncompiled_routine, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine\n</pre> from bartiq import compile_routine from bartiq.compilation import CompilationFlags  compiled_routine = compile_routine(uncompiled_routine, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine <p>It went pretty well, let's see what's the we got:</p> In\u00a0[10]: Copied! <pre>for resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*L + 4*mu + O(log2(L)) + 8*ceiling(log2(L/2**multiplicity(2, L))) - 16\nrotations: 2\n</pre> <p>In the caption of Fig. 11 we had: $4(L + \\mu) + O(\\log2(L))$, and these two expressions actually match pretty well.</p> <ul> <li>We have the $4(L + \\mu)$ as well as $O(log2(L))$ in both versions.</li> <li>The <code>8*ceiling(log2(L/2 ^ multiplicity(2, L)))</code> term is also $O(log2(L))$ in disguise.</li> <li>Constant factor of <code>-16</code> can also be incorporated in <code>O(log2(L))</code></li> </ul> <p>Let's see how it looks like for some concrete values:</p> In\u00a0[11]: Copied! <pre>from bartiq import evaluate\n\nassignments = {\"L\": 120, \"mu\": 8}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate  assignments = {\"L\": 120, \"mu\": 8} evaluated_routine = evaluate(compiled_routine, assignments).routine for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: O(log2(120)) + 528\nrotations: 2\n</pre> <p>We still have big O there, so we can't get a concrete number. So let's assume a simple case, i.e. <code>O(x) = ceiling(x)</code>. We'll provide information how to evaluate it in <code>bartiq</code> using <code>functions_map</code> argument.</p> In\u00a0[12]: Copied! <pre>import math\n\n\ndef big_O(x):\n    return math.ceil(x)\n\n\nfunctions_map = {\"O\": big_O}\nevaluation_result = evaluate(compiled_routine, assignments, functions_map=functions_map)\nqref_routine = evaluation_result.to_qref()\nfor resource in evaluation_result.routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> import math   def big_O(x):     return math.ceil(x)   functions_map = {\"O\": big_O} evaluation_result = evaluate(compiled_routine, assignments, functions_map=functions_map) qref_routine = evaluation_result.to_qref() for resource in evaluation_result.routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 535\nrotations: 2\n</pre> <p>And now we finally have some concrete numbers!</p> In\u00a0[13]: Copied! <pre>from bartiq.integrations import explore_routine\n\nexplore_routine(qref_routine)\n</pre> from bartiq.integrations import explore_routine  explore_routine(qref_routine) Out[13]: <pre>HBox(children=(VBox(children=(_RoutineTree(multiple_selection=False, nodes=(Node(name='alias_sampling', nodes=\u2026</pre> <p>If you'd prefer a static representation, you can also simply export routine to latex, though it only shows information about the top-level routine:</p> In\u00a0[14]: Copied! <pre>from bartiq.integrations import routine_to_latex\nfrom IPython.display import Math\n\nMath(routine_to_latex(qref_routine))\n</pre> from bartiq.integrations import routine_to_latex from IPython.display import Math  Math(routine_to_latex(qref_routine)) Out[14]:  $\\displaystyle \\begin{align} &amp;\\text{RoutineV1 \\textrm{(alias\\_sampling)}}\\newline &amp;\\underline{\\text{Input ports:}}\\\\ &amp;\\text{In\\_0} = 7\\\\ &amp;\\text{In\\_1} = 8\\\\ &amp;\\text{In\\_2} = 7\\\\ &amp;\\text{In\\_3} = 8\\\\ &amp;\\text{In\\_4} = 1\\newline &amp;\\underline{\\text{Output ports:}}\\\\ &amp;\\text{out\\_0} = 7\\\\ &amp;\\text{temp\\_0} = 8\\\\ &amp;\\text{temp\\_1} = 7\\\\ &amp;\\text{temp\\_2} = 8\\\\ &amp;\\text{temp\\_3} = 1\\newline &amp;\\underline{\\text{Resources:}}\\\\ &amp;T_{\\text{gates}} = 535\\\\ &amp;rotations = 2\\\\ &amp;\\text{usp}.\\!T_{\\text{gates}} = 24\\\\ &amp;\\text{usp}.\\!rotations = 2\\\\ &amp;\\text{qrom}.\\!T_{\\text{gates}} = 476\\\\ &amp;\\text{compare}.\\!T_{\\text{gates}} = 28\\\\ &amp;\\text{swap}.\\!T_{\\text{gates}} = 7 \\end{align}$  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/02_alias_sampling_basic/#alias-sampling","title":"Alias Sampling\u00b6","text":""},{"location":"tutorials/02_alias_sampling_basic/#exploring-the-estimates","title":"Exploring the estimates\u00b6","text":"<p>If we just interact with bare python objects, getting a quick idea of the values of various fields might be a bit cumbersome. That's where <code>explore_routine</code> functions might be helpful. Try it out using the snippet below.</p> <p>NOTE:</p> This is an interactive feature and will not render in the static version of the docs. To use it you need to run this tutorial as a jupyter notebook.  Remember to install bartiq with <code>pip install 'bartiq[jupyter]'</code> to make sure you have all the dependencies needed for these widgets to work (for more details visit installation docs\u00a0\u29c9)."},{"location":"tutorials/02_alias_sampling_basic/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to take an algorithm from a paper and compile it into <code>bartiq</code></li> <li>How to create a routine with multiple resources, <code>local_variables</code> and custom functions</li> <li>How to use <code>explore_routine</code> and latex integration to get most out of <code>bartiq</code></li> </ul>"},{"location":"tutorials/03_advanced_examples/","title":"Using Bartiq for Resource Analysis","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or clone the repository and go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>It is time to explore how to use <code>bartiq</code>'s resource estimation capabilities in practical quantum algorithm analysis. In this tutorial, we will:</p> <ul> <li>Compare resources of different implementations of the same operation/unitary using <code>bartiq</code>.</li> <li>Transform your estimate to obtain more useful information about the problem.</li> <li>Learn how to implement nested hierarchy in <code>bartiq</code>.</li> </ul> <p>In the previous tutorial\u00a0\u29c9, we demonstrated how the alias sampling algorithm works, along with its subroutines - USP, $H^{\\otimes\\mu}$, QROM, comparator, and controlled SWAP. Beyond the uniform state preparation (USP) method introduced in tutorial 02, several other USP implementations are worth considering as alternatives. You can think of these implementations as interchangeable quantum circuits\u3002</p> <p>In this tutorial we will see if we can make alias sampling use less resources by using a different implementation of USP.</p> <p>NOTE:</p> <p>This tutorial is not meant to provide definitive expressions. Instead, it is designed to guide you through relevant sections of the papers, obtain expressions and use them to demonstrate how <code>bartiq</code> works. If you find any mistakes or oversimplifications, please let us know!</p> <p>Additionally, future work may reveal that not all cost estimates are accurate, as some routines can be optimized further. However, explaining these optimizations is beyond the scope of this tutorial.</p> <p>The implementation of the <code>USP</code> method in Encoding Electronic Spectra...\u00a0\u29c9 has been described in tutorial 02\u00a0\u29c9. Let's do a quick recap.</p> <p>Here, we will break down the <code>USP</code> routine into more detailed operations, including the inequality test, rotation, (uncompute) inequality test, and a (controlled) rotation. Since these operations are not run in parallel nor share qubits at the same time, representing each individual subroutine is straightforward and intuitive. Below is the circuit diagram for the USP, adapted from Figure 12 of the original paper:</p> <p></p> <p>Below we have written some helper functions due to the repeated pattern of the dictionaries.</p> In\u00a0[1]: Copied! <pre>def generate_inequality_test(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\n                \"name\": \"T_gates\",\n                \"type\": \"additive\",\n                \"value\": \"4*ceiling(log2(L/(2 ** k))-1)\",\n            },\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},\n    }\n</pre> def generate_inequality_test(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {                 \"name\": \"T_gates\",                 \"type\": \"additive\",                 \"value\": \"4*ceiling(log2(L/(2 ** k))-1)\",             },         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},     } In\u00a0[2]: Copied! <pre>def generate_rotation(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log2(L))\"},\n    }\n</pre> def generate_rotation(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log2(L))\"},     } In\u00a0[3]: Copied! <pre>def generate_controlled_rotation(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},\n            {\n                \"name\": \"T_gates\",\n                \"type\": \"additive\",\n                \"value\": \"4*ceiling(log2(L/(2 ** k))-2)\",\n            },\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},\n    }\n</pre> def generate_controlled_rotation(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},             {                 \"name\": \"T_gates\",                 \"type\": \"additive\",                 \"value\": \"4*ceiling(log2(L/(2 ** k))-2)\",             },         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},     } <p>The dictionary for the entire algorithm is shown below. You might notice that, compared to the previous tutorial, we have introduced ancilla qubits as a new resource here. Yes, ancilla qubits can be considered a resource just like quantum gates. We include ancilla qubits in the overall USP routine, rather than in the subroutines, because the two inequality tests operate on the same set of ancillas. Additionally, we're considering reallocating the ancillas for the subsequent controlled rotation. We use type <code>qubits</code> for them, though at the moment Bartiq does not handle this type in any special way.</p> <p>Also, please note that these are arbitrary choices \u2013  you might want to experiment a bit to see which setup works best in your case.</p> In\u00a0[4]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"children\": [\n        generate_inequality_test(\"inequality_test_1\"),\n        generate_rotation(\"rotation\"),\n        generate_inequality_test(\"inequality_test_2\"),\n        generate_controlled_rotation(\"controlled_rotation\"),\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},\n    \"connections\": [\n        {\"source\": \"in\", \"target\": \"inequality_test_1.in\"},\n        {\"source\": \"inequality_test_1.out\", \"target\": \"rotation.in\"},\n        {\"source\": \"rotation.out\", \"target\": \"inequality_test_2.in\"},\n        {\"source\": \"inequality_test_2.out\", \"target\": \"controlled_rotation.in\"},\n        {\"source\": \"controlled_rotation.out\", \"target\": \"out\"},\n    ],\n    \"resources\": [\n        {\n            \"name\": \"ancilla\",\n            \"type\": \"qubits\",\n            \"value\": \"floor(log2(L/2 ** k))\",\n        },\n    ],\n    \"linked_params\": [\n        {\n            \"source\": \"L\",\n            \"targets\": [\"inequality_test_1.L\", \"rotation.L\", \"inequality_test_2.L\", \"controlled_rotation.L\"],\n        },\n    ],\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"children\": [         generate_inequality_test(\"inequality_test_1\"),         generate_rotation(\"rotation\"),         generate_inequality_test(\"inequality_test_2\"),         generate_controlled_rotation(\"controlled_rotation\"),     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"R\": \"ceiling(log2(L))\", \"k\": \"multiplicity(2,L)\"},     \"connections\": [         {\"source\": \"in\", \"target\": \"inequality_test_1.in\"},         {\"source\": \"inequality_test_1.out\", \"target\": \"rotation.in\"},         {\"source\": \"rotation.out\", \"target\": \"inequality_test_2.in\"},         {\"source\": \"inequality_test_2.out\", \"target\": \"controlled_rotation.in\"},         {\"source\": \"controlled_rotation.out\", \"target\": \"out\"},     ],     \"resources\": [         {             \"name\": \"ancilla\",             \"type\": \"qubits\",             \"value\": \"floor(log2(L/2 ** k))\",         },     ],     \"linked_params\": [         {             \"source\": \"L\",             \"targets\": [\"inequality_test_1.L\", \"rotation.L\", \"inequality_test_2.L\", \"controlled_rotation.L\"],         },     ], } In\u00a0[5]: Copied! <pre>from qref import SchemaV1\n\nuncompiled_usp = SchemaV1(version=\"v1\", program=usp_dict)\n</pre> from qref import SchemaV1  uncompiled_usp = SchemaV1(version=\"v1\", program=usp_dict) <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> In\u00a0[6]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(uncompiled_usp)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"usp\", format=\"png\")\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(uncompiled_usp)  # Render the Graphviz object to a PNG file gv_object.render(\"usp\", format=\"png\") gv_object Out[6]: <p>and if we use this usp_dict to replace the usp in previous tutorial\u00a0\u29c9's alias sampling example, we'll have the alias sampling with more detailed hierarchy, like this:</p> In\u00a0[7]: Copied! <pre>import json\n\n# Load the alias sampling file\nwith open(\"../data/alias_sampling_basic.json\", \"r\") as f:\n    as_data = json.load(f)\n</pre> import json  # Load the alias sampling file with open(\"../data/alias_sampling_basic.json\", \"r\") as f:     as_data = json.load(f) In\u00a0[8]: Copied! <pre>as_qref = as_data.copy()\nfor i, child in enumerate(as_qref[\"program\"][\"children\"]):\n    if child[\"name\"] == \"usp\":\n        as_qref[\"program\"][\"children\"][i] = usp_dict\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(as_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_nested\", format=\"png\")\ngv_object\n</pre> as_qref = as_data.copy() for i, child in enumerate(as_qref[\"program\"][\"children\"]):     if child[\"name\"] == \"usp\":         as_qref[\"program\"][\"children\"][i] = usp_dict  # Convert the qref format to Graphviz object gv_object = to_graphviz(as_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"alias_nested\", format=\"png\") gv_object Out[8]: <p>Anyway, let's come back to the compilation process of <code>USP</code> in <code>bartiq</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from bartiq import compile_routine\nfrom bartiq.compilation import CompilationFlags\n\ncompiled_usp = compile_routine(uncompiled_usp, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine\nfor resource in compiled_usp.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import compile_routine from bartiq.compilation import CompilationFlags  compiled_usp = compile_routine(uncompiled_usp, compilation_flags=CompilationFlags.EXPAND_RESOURCES).routine for resource in compiled_usp.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>ancilla: floor(log2(L/2**multiplicity(2, L)))\nT_gates: 12*ceiling(log2(L/2**multiplicity(2, L))) - 16\nrz: 2\n</pre> <p>In the definition of rotation, we used <code>rz</code> as the resource.</p> <p>Here, we can use <code>add_aggregated_resources</code> function to decompose the <code>rz</code> gates into more fundamental, general non-Clifford gates. This function takes a dictionary that specifies how to decompose the gates and a bartiq routine as parameters. It synthesizes all matching resources within the bartiq routine according to the dictionary.</p> <p>In this context, we approximate $R_z(\\theta)$ gates using an approximation of 50 T gates base on the approximation from Efficient Clifford+T approximation of single-qubit operators\u00a0\u29c9 with error threshold $\\epsilon = 0.001$. The exact number will depend on the desired accuracy of the approximation, but 50 T gates will be a good choice for many applications.</p> In\u00a0[10]: Copied! <pre>from bartiq.transform import add_aggregated_resources\n\naggregation_dict = {\"rz\": {\"T_gates\": 50}}\naggregated_usp = add_aggregated_resources(compiled_usp, aggregation_dict)\n# Note that aggregation removed the `rz` resources:\nprint(aggregated_usp.children[\"rotation\"].resources)\n</pre> from bartiq.transform import add_aggregated_resources  aggregation_dict = {\"rz\": {\"T_gates\": 50}} aggregated_usp = add_aggregated_resources(compiled_usp, aggregation_dict) # Note that aggregation removed the `rz` resources: print(aggregated_usp.children[\"rotation\"].resources) <pre>{'T_gates': Resource(name='T_gates', type=&lt;ResourceType.additive: 'additive'&gt;, value=50)}\n</pre> <p>Here is the final result of our resource estimation for the <code>USP</code> routine, contains only T gates and ancilla qubits:</p> In\u00a0[11]: Copied! <pre>for resource in aggregated_usp.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in aggregated_usp.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>ancilla: floor(log2(L/2**multiplicity(2, L)))\nT_gates: 12*ceiling(log2(L/2**multiplicity(2, L))) + 84\n</pre> In\u00a0[12]: Copied! <pre>from bartiq import evaluate\n\nvalues = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\": value} for value in values]\n\nfor assignments in assignments_list:\n    evaluated_usp = evaluate(aggregated_usp, assignments).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_usp.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate  values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\": value} for value in values]  for assignments in assignments_list:     evaluated_usp = evaluate(aggregated_usp, assignments).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_usp.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 5}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 6}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 7}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 9}\n  ancilla: 3\n  T_gates: 132\nAssignment: {'L': 10}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 12}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 14}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 15}\n  ancilla: 3\n  T_gates: 132\n</pre> <p>An alternative approach to USP is presented in \"An efficient quantum algorithm for preparation of uniform quantum superposition states\u00a0\u29c9\". This work eliminates the need for ancilla qubits while maintaining similar asymptotic scaling to the other approach. We will refer to this as the <code>ZeroAncillaUSP</code>; the gate count for this method is detailed in Section 2.5 of the paper. Here, we will focus on the non-Clifford gate overhead and ignore the Clifford costs.</p> <p>To create a uniform superposition of $ L $ basis states using the <code>ZeroAncillaUSP</code> method, the following non-Clifford gate overhead is required:</p> In\u00a0[13]: Copied! <pre>zeroanc_usp_dict = {\n    \"name\": \"zeroanc_usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\n        \"l_0\": \"trailing(L)\",\n        \"R\": \"ceiling(log2(L))\",\n        \"l_k\": \"floor(log2(L))\",\n        \"k\": \"bin_bitcount(L) - 1 \",\n    },\n    \"resources\": [\n        {\"name\": \"ry\", \"type\": \"additive\", \"value\": \"1\"},\n        {\"name\": \"control_ry\", \"type\": \"additive\", \"value\": \"k - 1\"},\n        {\"name\": \"control_H\", \"type\": \"additive\", \"value\": \"l_k - l_0\"},\n    ],\n}\n</pre> zeroanc_usp_dict = {     \"name\": \"zeroanc_usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {         \"l_0\": \"trailing(L)\",         \"R\": \"ceiling(log2(L))\",         \"l_k\": \"floor(log2(L))\",         \"k\": \"bin_bitcount(L) - 1 \",     },     \"resources\": [         {\"name\": \"ry\", \"type\": \"additive\", \"value\": \"1\"},         {\"name\": \"control_ry\", \"type\": \"additive\", \"value\": \"k - 1\"},         {\"name\": \"control_H\", \"type\": \"additive\", \"value\": \"l_k - l_0\"},     ], } <p>As you can see, we use custom functions <code>trailing</code> and <code>bin_bitcount</code> \u2013 that's fine, because Bartiq can handle arbitrary functions, but we'll also define them later.</p> In\u00a0[14]: Copied! <pre>uncompiled_zeroanc = SchemaV1(version=\"v1\", program=zeroanc_usp_dict)\n</pre> uncompiled_zeroanc = SchemaV1(version=\"v1\", program=zeroanc_usp_dict) <p>Here is the resource expression for <code>ZeroAncillaUSP</code>:</p> In\u00a0[15]: Copied! <pre>for resource in uncompiled_zeroanc.program.resources:\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in uncompiled_zeroanc.program.resources:     print(f\"{resource.name}: {resource.value}\") <pre>control_H: l_k - l_0\ncontrol_ry: k - 1\nry: 1\n</pre> <p>Again, we decompose the <code>control_ry</code> and <code>control_H</code> gates to T gate approximations:</p> <ul> <li>control_ry: A controlled $R_Y (\\theta)$ gate, which contains 2 ry gates after decomposition.</li> <li>control_H: A controlled Hadamard gate, contains 2 T gates after gate synthesis.</li> <li>$R_Y (\\theta)$: A ry gate, similar to an rz gate, can be approximated by about 50 T gates with $\\epsilon = 0.001$.</li> </ul> In\u00a0[16]: Copied! <pre>compiled_zeroanc = compile_routine(uncompiled_zeroanc).routine\naggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}}\naggregated_zeroanc = add_aggregated_resources(compiled_zeroanc, aggregation_dict)\nfor resource in aggregated_zeroanc.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_zeroanc = compile_routine(uncompiled_zeroanc).routine aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}} aggregated_zeroanc = add_aggregated_resources(compiled_zeroanc, aggregation_dict) for resource in aggregated_zeroanc.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 100*bin_bitcount(L) - 2*trailing(L) + 2*floor(log2(L)) - 150\n</pre> In\u00a0[17]: Copied! <pre>import sympy\n\n\ndef trailing(x):\n    return sympy.trailing(x)\n\n\ndef bin_bitcount(x):\n    return bin(x).count(\"1\")\n\n\nfunctions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}\nvalues = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\": value} for value in values]\n\nfor assignments in assignments_list:\n    evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments, functions_map=functions_map).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_zeroanc.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> import sympy   def trailing(x):     return sympy.trailing(x)   def bin_bitcount(x):     return bin(x).count(\"1\")   functions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount} values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\": value} for value in values]  for assignments in assignments_list:     evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments, functions_map=functions_map).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_zeroanc.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  T_gates: 52\nAssignment: {'L': 5}\n  T_gates: 54\nAssignment: {'L': 6}\n  T_gates: 52\nAssignment: {'L': 7}\n  T_gates: 154\nAssignment: {'L': 9}\n  T_gates: 56\nAssignment: {'L': 10}\n  T_gates: 54\nAssignment: {'L': 12}\n  T_gates: 52\nAssignment: {'L': 14}\n  T_gates: 154\nAssignment: {'L': 15}\n  T_gates: 256\n</pre> <p>As a variation of the method described in Encoding Electronic Spectra...\u00a0\u29c9, we introduce another approach to state preparation using inequality tests, known as the Repeat-Until-Success (RUS) USP.</p> In\u00a0[18]: Copied! <pre>rus_usp_dict = {\n    \"name\": \"rus_usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"k\": \"multiplicity(2,L)\", \"R\": \"ceiling(log2(L))\", \"trial\": \"num_iter(L)\"},\n    \"resources\": [\n        {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*trial*ceiling(log2(L/(2 ** k))-1)\"},\n        {\"name\": \"ancilla\", \"type\": \"additive\", \"value\": \"floor(log2(L/2 ** k))\"},\n    ],\n}\n</pre> rus_usp_dict = {     \"name\": \"rus_usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"k\": \"multiplicity(2,L)\", \"R\": \"ceiling(log2(L))\", \"trial\": \"num_iter(L)\"},     \"resources\": [         {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*trial*ceiling(log2(L/(2 ** k))-1)\"},         {\"name\": \"ancilla\", \"type\": \"additive\", \"value\": \"floor(log2(L/2 ** k))\"},     ], } In\u00a0[19]: Copied! <pre>uncompiled_rus = SchemaV1(version=\"v1\", program=rus_usp_dict)\n</pre> uncompiled_rus = SchemaV1(version=\"v1\", program=rus_usp_dict) In\u00a0[20]: Copied! <pre>compiled_rus = compile_routine(uncompiled_rus).routine\n\nfor resource in compiled_rus.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_rus = compile_routine(uncompiled_rus).routine  for resource in compiled_rus.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*(ceiling(log2(L/2**multiplicity(2, L))) - 1)*num_iter(L)\nancilla: floor(log2(L/2**multiplicity(2, L)))\n</pre> <p>This estimation arises because it is equivalent to performing two cost inequality tests. Each test has a Toffoli gate count of $\\lceil \\log2 \\left(L/2^k\\right) \\rceil - 1$. According to Halving the cost of quantum addition\u00a0\u29c9, when the input of the target is known to be in $| 0 \\rangle$, each Toffoli gate can be decomposed into 4 T gates. Additionally, the T gate cost for the uncompute inequality test (the second one) can be ignored.</p> <p>Now let's look at how to calculate <code>num_iter(L)</code>.</p> <p>The probability of success in each trial is determined by the ratio of $L$ to the smallest power of 2 that is greater than or equal to  $L$. This function  below provides a rough estimation of the number of trials needed to achieve a target success probability (default is 99%) based on the geometric distribution. This means it may not match the actual number of trials required each time, as the process is probabilistic, but gives us the estimation for an average case.</p> <p>Here's how you can estimate the number of trials:</p> In\u00a0[21]: Copied! <pre>import math\n\n\ndef calculate_trials(d, target_probability=0.99):\n    prob = d / (1 &lt;&lt; math.ceil(math.log2(d)))\n    return math.ceil(math.log(1 - target_probability) / math.log(1 - prob))\n</pre> import math   def calculate_trials(d, target_probability=0.99):     prob = d / (1 &lt;&lt; math.ceil(math.log2(d)))     return math.ceil(math.log(1 - target_probability) / math.log(1 - prob)) In\u00a0[22]: Copied! <pre>L = 7\nnum_trials = calculate_trials(7)\nprint(f\"For L={L}, the estimated number of trials needed is: {num_trials}\")\n</pre> L = 7 num_trials = calculate_trials(7) print(f\"For L={L}, the estimated number of trials needed is: {num_trials}\") <pre>For L=7, the estimated number of trials needed is: 3\n</pre> In\u00a0[23]: Copied! <pre>values = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\": value} for value in values]\n\nfunctions_map = {\"num_iter\": calculate_trials}\n\nfor assignments in assignments_list:\n    evaluated_rus = evaluate(compiled_rus, assignments, functions_map=functions_map).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_rus.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\": value} for value in values]  functions_map = {\"num_iter\": calculate_trials}  for assignments in assignments_list:     evaluated_rus = evaluate(compiled_rus, assignments, functions_map=functions_map).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_rus.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 5}\n  T_gates: 40\n  ancilla: 2\nAssignment: {'L': 6}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 7}\n  T_gates: 24\n  ancilla: 2\nAssignment: {'L': 9}\n  T_gates: 72\n  ancilla: 3\nAssignment: {'L': 10}\n  T_gates: 40\n  ancilla: 2\nAssignment: {'L': 12}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 14}\n  T_gates: 24\n  ancilla: 2\nAssignment: {'L': 15}\n  T_gates: 24\n  ancilla: 3\n</pre> <p>Now, we can compare the cost performance of different USP methods for some concrete data.</p> <p>Here, we generate some instances that are not powers of 2 (when $L$ is a power of 2, only Hadamard gates are needed).</p> In\u00a0[24]: Copied! <pre>def is_power_of_two(n):\n    return (n &amp; (n - 1) == 0) and n != 0\n\n\nall_values = [x for x in range(5, 600) if not is_power_of_two(x)]\nL_values = all_values\n</pre> def is_power_of_two(n):     return (n &amp; (n - 1) == 0) and n != 0   all_values = [x for x in range(5, 600) if not is_power_of_two(x)] L_values = all_values In\u00a0[25]: Copied! <pre># USP\nusp_tgates = []\nusp_ancilla = []\n\nfor L in L_values:\n    assignments_list = {\"L\": L}\n    evaluated_usp = evaluate(aggregated_usp, assignments_list).routine\n    usp_tgates.append(math.ceil(float(evaluated_usp.resources[\"T_gates\"].value)))\n    if \"ancilla\" in evaluated_usp.resources:\n        usp_ancilla.append(int(evaluated_usp.resources[\"ancilla\"].value))\n    else:\n        usp_ancilla.append(0)\n</pre> # USP usp_tgates = [] usp_ancilla = []  for L in L_values:     assignments_list = {\"L\": L}     evaluated_usp = evaluate(aggregated_usp, assignments_list).routine     usp_tgates.append(math.ceil(float(evaluated_usp.resources[\"T_gates\"].value)))     if \"ancilla\" in evaluated_usp.resources:         usp_ancilla.append(int(evaluated_usp.resources[\"ancilla\"].value))     else:         usp_ancilla.append(0) In\u00a0[26]: Copied! <pre># Zeroanc_USP\nzeroanc_tgates = []\nzeroanc_ancilla = []\n\nfunctions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}\n\nfor L in L_values:\n    assignments_list = {\"L\": L}\n    evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments_list, functions_map=functions_map).routine\n    zeroanc_tgates.append(int(evaluated_zeroanc.resources[\"T_gates\"].value))\n    if \"ancilla\" in evaluated_zeroanc.resources:\n        zeroanc_ancilla.append(int(evaluated_zeroanc.resources[\"ancilla\"].value))\n    else:\n        zeroanc_ancilla.append(0)\n</pre> # Zeroanc_USP zeroanc_tgates = [] zeroanc_ancilla = []  functions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}  for L in L_values:     assignments_list = {\"L\": L}     evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments_list, functions_map=functions_map).routine     zeroanc_tgates.append(int(evaluated_zeroanc.resources[\"T_gates\"].value))     if \"ancilla\" in evaluated_zeroanc.resources:         zeroanc_ancilla.append(int(evaluated_zeroanc.resources[\"ancilla\"].value))     else:         zeroanc_ancilla.append(0) In\u00a0[27]: Copied! <pre># RUS_USP\nrus_tgates = []\nrus_ancilla = []\n\nfunctions_map = {\"num_iter\": calculate_trials}\n\nfor L in L_values:\n    assignments_list = {\"L\": L}\n    evaluated_rus = evaluate(compiled_rus, assignments_list, functions_map=functions_map).routine\n    rus_tgates.append(int(evaluated_rus.resources[\"T_gates\"].value))\n    if \"ancilla\" in evaluated_rus.resources:\n        rus_ancilla.append(int(evaluated_rus.resources[\"ancilla\"].value))\n    else:\n        rus_ancilla.append(0)\n</pre> # RUS_USP rus_tgates = [] rus_ancilla = []  functions_map = {\"num_iter\": calculate_trials}  for L in L_values:     assignments_list = {\"L\": L}     evaluated_rus = evaluate(compiled_rus, assignments_list, functions_map=functions_map).routine     rus_tgates.append(int(evaluated_rus.resources[\"T_gates\"].value))     if \"ancilla\" in evaluated_rus.resources:         rus_ancilla.append(int(evaluated_rus.resources[\"ancilla\"].value))     else:         rus_ancilla.append(0) In\u00a0[28]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 8))\n\nplt.plot(L_values, usp_tgates, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=4, linestyle=\"--\")\nplt.plot(L_values, zeroanc_tgates, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=4, linestyle=\"-\")\nplt.plot(L_values, rus_tgates, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=4, linestyle=\"-\")\n\nplt.title(\"Number of T Gates Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\")\nplt.xlabel(\"L\", fontsize=14)\nplt.ylabel(\"Number of T Gates\", fontsize=14)\n\nplt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\")\nplt.legend().get_frame().set_facecolor(\"lightgrey\")\n\nplt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  plt.figure(figsize=(12, 8))  plt.plot(L_values, usp_tgates, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=4, linestyle=\"--\") plt.plot(L_values, zeroanc_tgates, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=4, linestyle=\"-\") plt.plot(L_values, rus_tgates, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=4, linestyle=\"-\")  plt.title(\"Number of T Gates Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\") plt.xlabel(\"L\", fontsize=14) plt.ylabel(\"Number of T Gates\", fontsize=14)  plt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\") plt.legend().get_frame().set_facecolor(\"lightgrey\")  plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)  plt.tight_layout() plt.show() In\u00a0[29]: Copied! <pre>plt.figure(figsize=(12, 8))\n\nplt.plot(L_values, usp_ancilla, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=6, linestyle=\"--\")\nplt.plot(L_values, zeroanc_ancilla, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=6, linestyle=\"-\")\nplt.plot(L_values, rus_ancilla, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=6, linestyle=\"-\")\n\nplt.title(\"Number of Ancilla Qubits Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\")\nplt.xlabel(\"L\", fontsize=14)\nplt.ylabel(\"Number of ancillas\", fontsize=14)\n\nplt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\")\nplt.legend().get_frame().set_facecolor(\"lightgrey\")\n\nplt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(12, 8))  plt.plot(L_values, usp_ancilla, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=6, linestyle=\"--\") plt.plot(L_values, zeroanc_ancilla, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=6, linestyle=\"-\") plt.plot(L_values, rus_ancilla, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=6, linestyle=\"-\")  plt.title(\"Number of Ancilla Qubits Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\") plt.xlabel(\"L\", fontsize=14) plt.ylabel(\"Number of ancillas\", fontsize=14)  plt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\") plt.legend().get_frame().set_facecolor(\"lightgrey\")  plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)  plt.tight_layout() plt.show() <p>...and we leave the analysis up to you! Decide by yourself which USP implementation suits your needs best!</p> <p>Finally, we'll explore integrating different USP expressions into Alias Sampling. By substituting various USP formulations, we'll see how these changes impact the overall expression and sampling results.</p> <p>Since substituting subroutines is easiest at the level of QREF dictionaries what we'll do is:</p> <ul> <li>take Alias Sampling routine</li> <li>replace the <code>usp</code> subroutine with another dictionary</li> <li>rename it to <code>usp</code> to make sure the connections are valid</li> </ul> In\u00a0[30]: Copied! <pre>import copy\n\n# usp\nas_usp_dict = copy.copy(as_data)\nas_usp_dict[\"program\"][\"children\"][0] = usp_dict\n\ncompiled_as_usp = compile_routine(SchemaV1(**as_usp_dict)).routine\n</pre> import copy  # usp as_usp_dict = copy.copy(as_data) as_usp_dict[\"program\"][\"children\"][0] = usp_dict  compiled_as_usp = compile_routine(SchemaV1(**as_usp_dict)).routine In\u00a0[31]: Copied! <pre># zeroanc_usp\nas_zeroanc_usp_dict = copy.copy(as_data)\nzeroanc_usp_dict[\"name\"] = \"usp\"\nas_zeroanc_usp_dict[\"program\"][\"children\"][0] = zeroanc_usp_dict\n\ncompiled_as_zeroanc = compile_routine(SchemaV1(**as_zeroanc_usp_dict)).routine\n</pre> # zeroanc_usp as_zeroanc_usp_dict = copy.copy(as_data) zeroanc_usp_dict[\"name\"] = \"usp\" as_zeroanc_usp_dict[\"program\"][\"children\"][0] = zeroanc_usp_dict  compiled_as_zeroanc = compile_routine(SchemaV1(**as_zeroanc_usp_dict)).routine In\u00a0[32]: Copied! <pre># rus_usp\nas_rus_usp_dict = copy.copy(as_data)\nrus_usp_dict[\"name\"] = \"usp\"\nas_rus_usp_dict[\"program\"][\"children\"][0] = rus_usp_dict\n\ncompiled_as_rus = compile_routine(SchemaV1(**as_rus_usp_dict)).routine\n</pre> # rus_usp as_rus_usp_dict = copy.copy(as_data) rus_usp_dict[\"name\"] = \"usp\" as_rus_usp_dict[\"program\"][\"children\"][0] = rus_usp_dict  compiled_as_rus = compile_routine(SchemaV1(**as_rus_usp_dict)).routine <p>Now we'll just once again add the aggregated costs, this time using the same <code>aggregation_dict</code> for all the routines:</p> In\u00a0[33]: Copied! <pre>aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}, \"rz\": {\"T_gates\": 50}}\ncompiled_as_usp = add_aggregated_resources(compiled_as_usp, aggregation_dict)\ncompiled_as_zeroanc = add_aggregated_resources(compiled_as_zeroanc, aggregation_dict)\ncompiled_as_rus = add_aggregated_resources(compiled_as_rus, aggregation_dict)\n</pre> aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}, \"rz\": {\"T_gates\": 50}} compiled_as_usp = add_aggregated_resources(compiled_as_usp, aggregation_dict) compiled_as_zeroanc = add_aggregated_resources(compiled_as_zeroanc, aggregation_dict) compiled_as_rus = add_aggregated_resources(compiled_as_rus, aggregation_dict) In\u00a0[34]: Copied! <pre>from sympy import symbols, Function, sympify, latex, expand, Add\n\ntrailing, binbitcount, multiplicity, numiter, O = map(\n    Function, [\"trailing\", \"bin-bitcount\", \"multiplicity\", \"num-iter\", \"O\"]\n)\nL, mu = symbols(\"L mu\")\n\nT_count = {\n    \"usp\": compiled_as_usp.resources[\"T_gates\"].value,\n    \"anc\": compiled_as_zeroanc.resources[\"T_gates\"].value,\n    \"rus\": compiled_as_rus.resources[\"T_gates\"].value,\n}\nlocals_dict = {\n    \"multiplicity\": multiplicity,\n    \"O\": O,\n    \"bin_bitcount\": binbitcount,\n    \"trailing\": trailing,\n    \"num_iter\": numiter,\n}\nexpr_usp, expr_anc, expr_rus = [sympify(T_count[key], locals=locals_dict) for key in [\"usp\", \"anc\", \"rus\"]]\n</pre> from sympy import symbols, Function, sympify, latex, expand, Add  trailing, binbitcount, multiplicity, numiter, O = map(     Function, [\"trailing\", \"bin-bitcount\", \"multiplicity\", \"num-iter\", \"O\"] ) L, mu = symbols(\"L mu\")  T_count = {     \"usp\": compiled_as_usp.resources[\"T_gates\"].value,     \"anc\": compiled_as_zeroanc.resources[\"T_gates\"].value,     \"rus\": compiled_as_rus.resources[\"T_gates\"].value, } locals_dict = {     \"multiplicity\": multiplicity,     \"O\": O,     \"bin_bitcount\": binbitcount,     \"trailing\": trailing,     \"num_iter\": numiter, } expr_usp, expr_anc, expr_rus = [sympify(T_count[key], locals=locals_dict) for key in [\"usp\", \"anc\", \"rus\"]] In\u00a0[35]: Copied! <pre>from IPython.display import display, Math\n\n# Find the common term in these expressions\ncommon_expr = sum(\n    set(Add.make_args(expand(expr_usp))) &amp; set(Add.make_args(expand(expr_anc))) &amp; set(Add.make_args(expand(expr_rus)))\n)\n\ndisplay(Math(f\"\\\\text{{Common Terms in Alias Sampling with Different USPs: }} {latex(common_expr)}\"))\n</pre> from IPython.display import display, Math  # Find the common term in these expressions common_expr = sum(     set(Add.make_args(expand(expr_usp))) &amp; set(Add.make_args(expand(expr_anc))) &amp; set(Add.make_args(expand(expr_rus))) )  display(Math(f\"\\\\text{{Common Terms in Alias Sampling with Different USPs: }} {latex(common_expr)}\"))  $\\displaystyle \\text{Common Terms in Alias Sampling with Different USPs: } 4 L + 4 \\mu + O{\\left(\\operatorname{log}_{2}{\\left(L \\right)} \\right)}$  In\u00a0[36]: Copied! <pre>display(Math(f\"\\\\text{{Differential Terms Using the USP Method: }} {latex(expr_usp - common_expr)}\"))\ndisplay(Math(f\"\\\\text{{Differential Terms Using the Zero Ancilla USP Method: }}  {latex(expr_anc - common_expr)}\"))\ndisplay(Math(f\"\\\\text{{Difference Terms Using the RUS\\\\_USP Method: }}{latex(expr_rus - common_expr)}\"))\n</pre> display(Math(f\"\\\\text{{Differential Terms Using the USP Method: }} {latex(expr_usp - common_expr)}\")) display(Math(f\"\\\\text{{Differential Terms Using the Zero Ancilla USP Method: }}  {latex(expr_anc - common_expr)}\")) display(Math(f\"\\\\text{{Difference Terms Using the RUS\\\\_USP Method: }}{latex(expr_rus - common_expr)}\"))  $\\displaystyle \\text{Differential Terms Using the USP Method: } 12 \\left\\lceil{\\operatorname{log}_{2}{\\left(2^{- \\operatorname{multiplicity}{\\left(2,L \\right)}} L \\right)}}\\right\\rceil + 76$   $\\displaystyle \\text{Differential Terms Using the Zero Ancilla USP Method: }  100 \\operatorname{bin}_{bitcount}{\\left(L \\right)} - 2 \\operatorname{trailing}{\\left(L \\right)} + 2 \\left\\lfloor{\\operatorname{log}_{2}{\\left(L \\right)}}\\right\\rfloor - 158$   $\\displaystyle \\text{Difference Terms Using the RUS\\_USP Method: }4 \\left(\\left\\lceil{\\operatorname{log}_{2}{\\left(2^{- \\operatorname{multiplicity}{\\left(2,L \\right)}} L \\right)}}\\right\\rceil - 1\\right) \\operatorname{num}_{iter}{\\left(L \\right)} - 8$"},{"location":"tutorials/03_advanced_examples/#using-bartiq-for-resource-analysis","title":"Using Bartiq for Resource Analysis\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#usp-implementations","title":"USP Implementations\u00b6","text":"<p>Let's start by setting up different USP routines in <code>bartiq</code>.</p> <p>We will analyze three distinct uniform state preparation routines:</p> <ol> <li>USP: The basic uniform state preparation routine introduced in Encoding Electronic Spectra...\u00a0\u29c9, also the one used in tutorial 02\u00a0\u29c9.</li> <li>ZeroAncillaUSP: A more recent construction that eliminates the need for any ancilla qubits, as presented in An efficient quantum algorithm for preparation of uniform quantum superposition states\u00a0\u29c9.</li> <li>RUS_USP:  A variation of the method described in Encoding Electronic Spectra...\u00a0\u29c9, using Repeat-Until-Success approach.</li> </ol> <p>Throughout this notebook, we will refer to these routines as <code>USP</code>, <code>ZeroAncillaUSP</code> and <code>RUS_USP</code> respectively.</p>"},{"location":"tutorials/03_advanced_examples/#usp","title":"USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#parameters","title":"Parameters\u00b6","text":"<p>To prepares a state which is a uniform superposition over $L$ basis states:</p> <ul> <li>$L$: Number of coefficients we want to load.</li> <li>$k$: The largest integer such that $2^k$ divides $L$ , $k = \\textrm{multiplicity}(2, L)$.</li> </ul> <p>Note: These expressions only valid if $L$ is not a power of two, as in such case we can trivially implement USP using a layer of Hadamard gates.</p>"},{"location":"tutorials/03_advanced_examples/#visualizion-of-the-usp-routine","title":"Visualizion of the <code>USP</code> routine\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#numerical-evaluation-examples","title":"Numerical Evaluation Examples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#zero-ancilla-usp","title":"Zero Ancilla USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#non-clifford-gate-overhead","title":"Non-Clifford Gate Overhead\u00b6","text":"<ul> <li>$R_Y (\\theta)$ gate: 1.</li> <li>Controlled Hadamard gate: $l_k - l_0$.</li> <li>Controlled-$R_Y (\\theta)$ gate: $k - 1$.</li> </ul>"},{"location":"tutorials/03_advanced_examples/#parameters","title":"Parameters\u00b6","text":"<ul> <li>$l_0, l_1, \\ldots, l_k$: This is a sequence of integers where $L = \\sum_{j=0}^k 2^{l_j}$ and $0 \\le l_0 &lt; l_1 &lt; \\ldots &lt; l_{k-1} &lt; l_k \\le n-1$. In simpler terms:<ul> <li>$l_0$ is the position of the trailing zero in the binary representation of $L$.</li> <li>$l_k$ is the position of the highest set bit, or $\\lfloor \\log2(L) \\rfloor$.</li> <li>$k$ is the number of non-zero bits in the binary representation of $L$. Note: This is different from $k$ in <code>USP</code>.</li> </ul> </li> </ul> <p>Using these parameters, you can determine the specific gate overhead required for the <code>ZeroAncillaUSP</code> method in <code>bartiq</code>.</p>"},{"location":"tutorials/03_advanced_examples/#numerical-evaluation-examples","title":"Numerical Evaluation Examples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#repeat-until-success-rus-usp","title":"Repeat-Until-Success (RUS) USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#what-is-rus","title":"What is RUS?\u00b6","text":"<p>The Repeat-Until-Success (RUS) method is a probabilistic technique where attempts are repeatedly made until a successful result is achieved. Failed attempts are discarded, and only the final successful state is retained. Comparing to the method described in Encoding Electronic Spectra...\u00a0\u29c9, <code>RUS_USP</code> omits the amplitude amplification step, but requires a non-deterministic number of repetitions.</p>"},{"location":"tutorials/03_advanced_examples/#resource-estimation-for-repetition","title":"Resource Estimation for Repetition\u00b6","text":"<p>Below, we symbolically estimate the resources required for <code>RUS_USP</code>:</p>"},{"location":"tutorials/03_advanced_examples/#repetition-number","title":"Repetition Number\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#total-resource-estimation","title":"Total Resource Estimation\u00b6","text":"<p>By combining the estimated repetition number with the resource estimation for a single repetition, we can do the numeric evaluation of the total resources required.</p>"},{"location":"tutorials/03_advanced_examples/#comparison","title":"Comparison\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#make-the-samples","title":"Make the Samples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#resource-estimation","title":"Resource Estimation\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#plotting-the-result-of-t_gates","title":"Plotting the Result of T_gates\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#plotting-the-results-of-ancilla-qubits","title":"Plotting the Results of Ancilla Qubits\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#alias-sampling-with-different-usp","title":"Alias Sampling with Different USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we explored the utility of <code>bartiq</code>'s resource estimation in more complex scenarios.</p> <ul> <li>How to explore how different implementations of a subroutine influence the resources required. TODO rephrase</li> <li>How to effectively utilize <code>bartiq</code> to handle nested subroutines and swap them.</li> <li>How to use aggregation functions to help us analyzing the problem.</li> </ul>"},{"location":"unitary_hack/blogpost/","title":"Unitary Hack Blogpost","text":""},{"location":"unitary_hack/blogpost/#introduction","title":"Introduction","text":"<p>Fault-tolerant quantum computing (FTQC) isn\u2019t a far-off goal anymore: PsiQuantum is committed to building a utility-scale computer in Australia by the end of 2027, and many other hardware companies have designed their roadmaps to reach utility-scale by the end of the decade. This machine will be able to run programs that classical computers simply cannot, but only if we have the algorithms that are ready to be run.</p> <p>Writing quantum algorithms for fault-tolerant quantum computers is difficult enough, and it\u2019s made harder by a lack of usable infrastructure. Most research teams still rely on custom scripts, manual derivations, or one-off tools for estimating how many logical qubits or gates their algorithms will require. These workflows are hard to share and scale, and almost impossible to standardize.</p> <p> Figure 1. a) An example simple algorithm that takes in a register of n qubits and performs routines A and B on them. b) Representation of the algorithm as a directional graph that is written in the QREF format and then processed by Bartiq to output the total QRE for the algorithm. The costs of routines A and B are separately defined in the QREF file.</p> <p>At PsiQuantum, we built Bartiq to address this problem directly. It\u2019s an open-source engine for creating modular, symbolic quantum resource estimates, which helps researchers gain insight about how their algorithms scale.</p> <p>These tools are just the start. In addition, researchers need better interfaces, smarter integrations, and more input from the broader software community. If you care about building developer infrastructure and want to work on something that directly accelerates the future of computing, we would love your help.</p>"},{"location":"unitary_hack/blogpost/#gap-in-the-available-tools-for-ftqc-algorithm-creation","title":"Gap in the available tools for FTQC algorithm creation","text":"<p>Before dedicated tools existed, researchers pieced together quantum resource estimates (QREs) the way a carpenter might build a bookshelf: using hand tools, trial and error, and a lot of \u201csawdust\u201d in the Appendix, leading to a situation where estimating the cost of running a quantum algorithm on a fault-tolerant quantum computer was more of an artisanal craft than a standardized engineering process. Researchers relied on a combination of custom Python and Mathematica scripts, manual derivations, and hand-assembled tables that ended up in lengthy appendices, resulting in papers with 60+ pages that take weeks to months to be properly understood. Moreover, many interesting new techniques ended up buried in some appendix and rarely revisited. These one-off resource estimates were good enough for papers, conferences, or internal prototypes, but they weren\u2019t easy to compare or designed to be shared and built upon by other researchers in the community.</p> <p> Figure 2. Circuit (a) and directional-graph (b) representation of the state-preparation algorithm from Fig. 11 of Babbush et al.; Phys. Rev. X 8, 041015 (2018). Separate subroutines of the algorithm are framed in different colors for easier orientation. Without QREF and Bartiq, defining and processing such a large circuit would be challenging.</p> <p>As the FTQC-algorithms ecosystem grows, especially given the recent momentum toward FTQC hardware, the need for automation and structure in the development process is growing in parallel. The growth of the ecosystem also increases the number of connections between participants, which creates more opportunities for collaboration and exchange of information. Individual researchers also need to more easily understand how their routines scale and how they can be reused across applications to accelerate the development of FTQC algorithms.</p> <p>This has prompted the development of new QRE tools. Across the quantum landscape, multiple companies and research groups are working on software to improve resource estimation. At PsiQuantum, our work in this space revealed two especially persistent problems. First, tools often couldn\u2019t talk to each other \u2013 there was no shared format for representing QREs across tools and enabling interoperability. Second, there was no scalable method for managing the symbolic resource expressions that arise when making QREs. Addressing these two gaps led us to the development of QREF and Bartiq, respectively.</p>"},{"location":"unitary_hack/blogpost/#qref-the-open-source-format-for-ftqc-algorithm-distribution","title":"QREF \u2013 the open-source format for FTQC algorithm distribution","text":"<p>The first gap that we addressed was interoperability. Even though more QRE tools are coming online, there is no consistent way for them to exchange algorithm information. That makes it difficult to combine tools, compare outputs, or build larger workflows across research teams. QREF (Quantum Resource Estimation Format) was designed to solve this.</p> <p>QREF is a lightweight, open-source format based on YAML that describes a quantum algorithm\u2019s structure and associated resource estimates. It includes support for symbolic cost expressions and parameterized inputs, and it is intentionally limited in scope: it doesn\u2019t try to enable circuit simulation or low-level compilation details; instead, it focuses on providing a blueprint-style description of a quantum algorithm that can be easily shared, parsed, and reused.</p> <p>With QREF, an algorithm defined by one researcher can be picked up by another, or integrated into another tool, without needing to reinterpret or reimplement the logic. This makes it possible to treat QREs as composable software artifacts rather than one-time exports buried in an appendix of a paper. That opens the door to more consistent benchmarking, higher-quality algorithm libraries, and easier collaboration between research groups and across QRE tools.</p> <p>The QREF format is just the start of the conversation; please raise an issue in the QREF repo\u00a0\u29c9 if you have any feedback.</p>"},{"location":"unitary_hack/blogpost/#bartiq-the-open-source-tool-for-gaining-insight-into-qre-scalability","title":"Bartiq \u2013 the open-source tool for gaining insight into QRE scalability","text":"<p>Interoperability solves part of the problem \u2014 but quantum algorithms don\u2019t need to produce just numbers; it could be helpful to produce symbolic cost expressions that describe how resources grow with the problem\u2019s size. That\u2019s where Bartiq comes in.</p> <p>Bartiq is a Python-based, open-source engine for compiling and analyzing symbolic quantum resource estimates. Researchers can define subroutines in terms of their costs, e.g., \u201cthis subroutine requires 2n*log n T-gates\u201d, and then to combine those subroutines into full algorithms. As the subroutines are combined, Bartiq tracks and manipulates the symbolic expressions representing various resource metrics, e.g., qubit count, gate depth, T-count, etc.</p> <p>Under the hood, Bartiq uses SymPy to manage algebraic expressions and substitutions. The result is a workflow where resource models remain composable and scalable, rather than collapsing into numeric estimates too soon. This is especially useful when comparing algorithm variants, analyzing bottlenecks or scaling of the algorithms.</p> <p>Importantly, Bartiq and QREF both operate at the logical circuit level. If you\u2019ve designed an algorithm and can describe it in high-level logical operations, you can export it to QREF, analyze it with Bartiq, and begin estimating and optimizing its fault-tolerant cost profile.</p>"},{"location":"unitary_hack/blogpost/#invitation-to-contribute-to-bartiqs-development","title":"Invitation to contribute to Bartiq\u2019s development","text":"<p>Both QREF and Bartiq are open-source, Python-based tools, and they\u2019re still evolving. The goal is to support the FTQC community by providing infrastructure that makes algorithm development faster, more transparent, and more easily reusable. However, reaching that goal has some dependance on the contributions from the community itself.</p> <p>That could mean contributing to new subroutines or cost models, improving the compilation engine, or helping with the integration into other tool chains. It could also mean just trying the tools, providing feedback, or proposing new use cases. Every contribution, large or small, helps strengthen the foundation for scalable FTQC algorithm development. We are actively developing Bartiq to improve its usability, expand the integration possibilities, and enhance its documentation. This effort is shaped by feedback from adopters and collaborators with the long-term vision being to build shared pipelines and libraries, which is the kind of infrastructure FTQC-algorithm-development software needs to become more like classical software engineering.</p> <p>We invite the community to explore, build, and improve because building better tools together now is how we will unlock the full potential of FTQC in the future.</p>"},{"location":"unitary_hack/issues/","title":"Unitary Hack issues","text":"<ul> <li>Improvements to the API docs\u00a0\u29c9</li> <li>Add function for calculating <code>circuit_volume</code>\u00a0\u29c9</li> <li>Fix displaying resource name <code>local_highwater</code>.\u00a0\u29c9</li> <li>Passing a non-integer into ntz results in unhelpful error message.\u00a0\u29c9</li> <li>Improve visualisation methods in Bartiq\u00a0\u29c9</li> <li>Add convenience functions for finding subroutines\u00a0\u29c9</li> </ul>"}]}